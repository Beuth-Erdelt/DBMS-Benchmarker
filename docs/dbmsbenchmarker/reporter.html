<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>dbmsbenchmarker.reporter API documentation</title>
<meta name="description" content=":Date: 2018-01-03
:Version: 0.9
:Authors: Patrick Erdelt â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dbmsbenchmarker.reporter</code></h1>
</header>
<section id="section-intro">
<p>:Date: 2018-01-03
:Version: 0.9
:Authors: Patrick Erdelt</p>
<p>Classes for generating reports for benchmarks.
This uses the class benchmarker of dbmsbenchmarker.</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">&#34;&#34;&#34;
:Date: 2018-01-03
:Version: 0.9
:Authors: Patrick Erdelt

Classes for generating reports for benchmarks.
This uses the class benchmarker of dbmsbenchmarker.

&#34;&#34;&#34;
from tabulate import tabulate
import logging
import pandas as pd
import matplotlib
import matplotlib.pyplot as plt
import os
import csv
import json
from dbmsbenchmarker import tools, monitor
import datetime
from tqdm import tqdm
import pickle
import sys



class reporter():
        &#34;&#34;&#34;
        Class for generating reports.
        This class serves as a base class and does not produce anything.
        &#34;&#34;&#34;
        def __init__(self, benchmarker):
                &#34;&#34;&#34;
                Construct a new &#39;reporter&#39; object.

                :param benchmarker: Object of benchmarker containing information about queries, connections and benchmark times
                :return: returns nothing
                &#34;&#34;&#34;
                self.benchmarker = benchmarker
        def init(self):
                &#34;&#34;&#34;
                Initializes report. This method is called every time a report is generated.

                :return: returns nothing
                &#34;&#34;&#34;
                pass
        def save(self, dataframe, title, subtitle, filename):
                &#34;&#34;&#34;
                Saves a report.

                :param dataframe: Report data given as a pandas DataFrame
                :param title: Title of the report
                :param subtitle: Subtitle of the report
                :param filename: Name of the file the report will be saved to
                :return: returns nothing
                &#34;&#34;&#34;
                pass
        def generate(self, numQuery, timer):
                &#34;&#34;&#34;
                Generates a report for a given query and a given timer.

                :param numQuery: Number of the query the report is about. Starts at 1.
                :param timer: Timer object
                :return: returns nothing
                &#34;&#34;&#34;
                # are there benchmarks for this query?
                print(&#34;Generate report&#34;)
                if not self.benchmarker.timerExecution.checkForSuccessfulBenchmarks(numQuery):
                        print(&#34;Missing data&#34;)
        def generateAll(self, timer):
                &#34;&#34;&#34;
                Generates all reports for the benchmarker object for a given timer.
                If benchmarker has a fixed query, only reports for this query are generated.

                :param timer: Timer object
                :return: returns nothing
                &#34;&#34;&#34;
                if not self.benchmarker.fixedQuery is None:
                        self.generate(self.benchmarker.fixedQuery, timer)
                else:
                        if self.benchmarker.bBatch:
                                range_runs = range(1,len(self.benchmarker.queries)+1)
                        else:
                                range_runs = tqdm(range(1,len(self.benchmarker.queries)+1))
                        for numQuery in range_runs:
                                self.generate(numQuery, timer)




class storer(reporter):
        &#34;&#34;&#34;
        Class for generating reports.
        This class saves a protocol in json and benchmarks as csv files.
        It also provides a load() method to restore previous benchmarks.
        &#34;&#34;&#34;
        def __init__(self, benchmarker):
                reporter.__init__(self, benchmarker)
        def save(self, dataframe, filename):
                &#34;&#34;&#34;
                Saves benchmark table of a query as csv file.

                :param dataframe: DataFrame containing connection names (columns) and benchmark times (rows)
                :param filename: Filename for csv file
                :return: returns nothing
                &#34;&#34;&#34;
                # transpose
                dft = dataframe.transpose()
                # set column names
                dft.columns = dft.iloc[0]
                # remove first row
                df_transposed = dft[1:]
                # convert to csv
                csv = df_transposed.to_csv(index_label=False,index=False)
                # save
                csv_file = open(filename, &#34;w&#34;)
                csv_file.write(csv)
                csv_file.close()
        def generate(self, numQuery, timer):
                &#34;&#34;&#34;
                Generates and saves a benchmark table of a given query as csv files per timer.

                :param numQuery: Number of query to save benchmarks of
                :param timer: Timer containing benchmark results
                :return: returns nothing
                &#34;&#34;&#34;
                self.writeProtocol()
                for t in timer:
                        # are there benchmarks for this query?
                        if not t.checkForSuccessfulBenchmarks(numQuery):
                                continue
                        logging.debug(&#34;saveBenchmarkOfQuery: &#34;+str(numQuery))
                        query = tools.query(self.benchmarker.queries[numQuery-1])
                        df = t.toDataFrame(numQuery)
                        # save as csv
                        self.save(
                                dataframe = df,
                                filename = self.benchmarker.path+&#39;/query_&#39;+str(numQuery)+&#39;_&#39;+t.name+&#39;.csv&#39;)
        def load(self, query, numQuery, timer):
                &#34;&#34;&#34;
                Loads benchmark table of a given query from csv files per timer.

                :param numQuery: Number of query to save benchmarks of
                :param query: Query object, because number of warmups is needed
                :param timer: Timer containing benchmark results
                :return: True if successful
                &#34;&#34;&#34;
                for t in timer:
                        # load execution benchmarks
                        filename = self.benchmarker.path+&#39;/query_&#39;+str(numQuery)+&#39;_&#39;+t.name+&#39;.csv&#39;
                        if os.path.isfile(filename):
                                df = pd.read_csv(filename)
                                df_t = df.transpose()
                                d = df.to_dict(orient=&#34;list&#34;)
                                t.appendTimes(d, query)#.warmup)
                                logging.debug(&#34;Read &#34;+filename)
                        else:
                                t.appendTimes({}, query)#.warmup)
                                logging.debug(filename + &#34; not found&#34;)
                                #return False
                return True
        def writeProtocol(self):
                &#34;&#34;&#34;
                Saves procol of benchmarker in JSON format.

                :return: returns nothing
                &#34;&#34;&#34;
                filename = self.benchmarker.path+&#39;/protocol.json&#39;
                with open(filename, &#39;w&#39;) as f:
                        json.dump(self.benchmarker.protocol, f)
        def readProtocol(self):
                &#34;&#34;&#34;
                Loads procol of benchmarker in JSON format.

                :return: returns nothing
                &#34;&#34;&#34;
                filename = self.benchmarker.path+&#39;/protocol.json&#39;
                with open(filename, &#39;r&#39;) as f:
                        self.benchmarker.protocol = json.load(f)





class printer(reporter):
        &#34;&#34;&#34;
        Class for generating reports.
        This class prints a survey to console.
        &#34;&#34;&#34;
        def __init__(self, benchmarker):
                reporter.__init__(self, benchmarker)
        def generate(self, numQuery, timer):
                &#34;&#34;&#34;
                Generates report for console output.
                This currently always prints the execution timer.
                Anonymizes dbms if activated.

                :param numQuery: Number of query to generate report of
                :param timer: Timer containing benchmark results
                :return: returns nothing
                &#34;&#34;&#34;
                # are there benchmarks for this query?
                if not self.benchmarker.timerExecution.checkForSuccessfulBenchmarks(numQuery):
                        return False
                # is query active?
                query = tools.query(self.benchmarker.queries[numQuery-1])
                if not query.active:
                        return False
                # get data
                stats = self.benchmarker.timerExecution.stats[numQuery-1]
                times = self.benchmarker.timerExecution.times[numQuery-1]
                # construct table header
                header = tools.timer.header_stats.copy()
                header_times = list(map(lambda h: &#34;w&#34;+str(h)+&#34;&#34;, list(range(1,query.warmup+1))))
                header.extend(header_times)
                header_times = list(map(lambda h: str(h)+&#34;&#34;, list(range(query.warmup+1,query.numRun+1))))
                header.extend(header_times)
                # format stats and times
                stats_output = {k: [list(map(lambda x: &#39;{:.{prec}f}&#39;.format(x, prec=2), sublist)) for sublist in [stat_q]] for k,stat_q in stats.items()}
                times_output = {k: [list(map(lambda x: &#39;{:.{prec}f}&#39;.format(x, prec=2), sublist)) for sublist in [time_q]] for k,time_q in times.items()}
                # add connection names
                data = []
                for c in sorted(self.benchmarker.dbms.keys()):
                        # is dbms active and we have data
                        if self.benchmarker.dbms[c].connectiondata[&#39;active&#39;]:
                                if c in stats_output and c in times_output:
                                        l = list([self.benchmarker.dbms[c].getName()])
                                        l.extend(*stats_output[c])
                                        l.extend(*times_output[c])
                                        data.append(l)
                # print table
                print(&#39;Q&#39;+str(numQuery)+&#39;: &#39;+query.title)
                print(tabulate(data,headers=header, tablefmt=&#34;grid&#34;, floatfmt=&#34;.2f&#34;))
                # print errors
                for key, value in self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;errors&#39;].items():
                        if len(value) &gt; 0:
                                firstpos = value.find(&#39;: &#39;)
                                if firstpos &gt; 0:
                                        print(key + &#39;: &#39; + value[firstpos:])
                                else:
                                        print(key + &#39;: &#39; + value)
                return data




class pickler(reporter):
        &#34;&#34;&#34;
        Class for generating reports.
        Generates a pickle file of statistics as a dataframe and saves it to disk.
        &#34;&#34;&#34;
        def __init__(self, benchmarker):
                reporter.__init__(self, benchmarker)
        def save(self, dataframe, filename):
                &#34;&#34;&#34;
                Saves report of a given query as pickle file of a dataframe per timer.
                Anonymizes dbms if activated.

                :param dataframe: Report data given as a pandas DataFrame (rows=dbms, cols=benchmarks)
                :param title: Title of the report
                :param subtitle: Subtitle of the report
                :param filename: Name of the file the report will be saved to
                :return: returns nothing
                &#34;&#34;&#34;
                f = open(filename, &#34;wb&#34;)
                pickle.dump(dataframe, f)
                f.close()
        def generate(self, numQuery, timer):
                &#34;&#34;&#34;
                Generates a pickle file of statistics as a dataframe and saves it to disk.
                Anonymizes dbms if activated.

                :param numQuery: Number of query to generate report of
                :param timer: Timer containing benchmark results
                :return: returns nothing
                &#34;&#34;&#34;
                for t in timer:
                        # are there benchmarks for this query?
                        if not t.checkForSuccessfulBenchmarks(numQuery):
                                continue
                        query = tools.query(self.benchmarker.queries[numQuery-1])
                        # is timer active for this query?
                        if not query.timer[t.name][&#39;active&#39;]:
                                continue
                        # is query active?
                        if not query.active:
                                continue
                        # convert statistics to DataFrame
                        dataframe = self.benchmarker.statsToDataFrame(numQuery, t)
                        # test if any rows left
                        #if (dataframe[(dataframe.T[1:] != 0).any()]).empty:
                        if dataframe.empty:
                                # ignore empty dataframes
                                return
                        # remove inactive connections
                        #dataframe = tools.dataframehelper.removeInactiveConnections(dataframe, self.benchmarker)
                        # add factor column
                        #dataframe = tools.dataframehelper.addFactor(dataframe, self.benchmarker.queryconfig[&#39;factor&#39;])
                        logging.debug(&#34;Pickle Q&#34;+str(numQuery)+&#34; for timer &#34;+t.name)
                        # save as plot
                        self.save(
                                dataframe = dataframe,
                                filename = self.benchmarker.path+&#39;/query_&#39;+str(numQuery)+&#39;_&#39;+t.name+&#39;_statistics.pickle&#39;)




class ploter(reporter):
        &#34;&#34;&#34;
        Class for generating reports.
        Generates a plot of the benchmarks as a time series and saves it to disk.
        &#34;&#34;&#34;
        def __init__(self, benchmarker):
                reporter.__init__(self, benchmarker)
        def save(self, dataframe, query, title, subtitle, filename):
                &#34;&#34;&#34;
                Saves report of a given query as plot image per timer.
                Anonymizes dbms if activated.

                :param dataframe: Report data given as a pandas DataFrame (rows=dbms, cols=benchmarks)
                :param query: Query object
                :param title: Title of the report
                :param subtitle: Subtitle of the report
                :param filename: Name of the file the report will be saved to
                :return: returns nothing
                &#34;&#34;&#34;
                # test if any rows left
                if len(dataframe.index) &lt; 1:
                        return False
                # transpose
                df_transposed = dataframe.transpose()
                # add index name
                df_transposed.index.name = subtitle
                # plot
                plotdata = df_transposed.plot(title=title)
                # scale y-axis: 0 to max plus 10%
                plotdata.set_ylim(0, df_transposed.max().max()*1.10,0)
                if query.warmup &gt; 0:
                        plt.axvline(x=query.numRunBegin, linestyle=&#34;--&#34;, color=&#34;black&#34;)
                if query.cooldown &gt; 0:
                        plt.axvline(x=query.numRunEnd, linestyle=&#34;--&#34;, color=&#34;black&#34;)
                plt.legend(title=&#34;DBMS&#34;)
                plt.savefig(filename, bbox_inches=&#39;tight&#39;)
                plt.close()
        def generate(self, numQuery, timer):
                &#34;&#34;&#34;
                Generates a plot of the benchmarks as a time series and saves it to disk.
                Anonymizes dbms if activated.

                :param numQuery: Number of query to generate report of
                :param timer: Timer containing benchmark results
                :return: returns nothing
                &#34;&#34;&#34;
                for t in timer:
                        # are there benchmarks for this query?
                        if not t.checkForSuccessfulBenchmarks(numQuery):
                                continue
                        query = tools.query(self.benchmarker.queries[numQuery-1])
                        # is timer active for this query?
                        if not query.timer[t.name][&#39;active&#39;]:
                                continue
                        # is query active?
                        if not query.active:
                                continue
                        # benchmark times as a datarame
                        df = self.benchmarker.benchmarksToDataFrame(numQuery, t)
                        logging.debug(&#34;Plot Q&#34;+str(numQuery)+&#34; for timer &#34;+t.name)
                        # save as plot
                        self.save(
                                dataframe = df,
                                query = query,
                                title = &#34;Q&#34;+str(numQuery)+&#34;: Time &#34;+t.name+&#34; [ms]&#34;,
                                subtitle = &#34;Warmup = &#34;+str(query.warmup)+&#34;, test runs = &#34;+str(query.numRun-query.warmup-query.cooldown)+&#34;, cooldown = &#34;+str(query.cooldown),
                                filename = self.benchmarker.path+&#39;/query_&#39;+str(numQuery)+&#39;_&#39;+t.name+&#39;_plot.png&#39;)



class dataframer(reporter):
        &#34;&#34;&#34;
        Class for generating reports.
        Generates a data frame of the benchmark times and saves it to disk as a pickle file.
        &#34;&#34;&#34;
        def __init__(self, benchmarker):
                reporter.__init__(self, benchmarker)
        def save(self, dataframe, title, subtitle, filename):
                &#34;&#34;&#34;
                Saves report of a given query as a dataframe.
                Anonymizes dbms if activated.

                :param dataframe: Report data given as a pandas DataFrame (rows=dbms, cols=benchmarks)
                :param title: Title of the report
                :param subtitle: Subtitle of the report
                :param filename: Name of the file the report will be saved to
                :return: returns nothing
                &#34;&#34;&#34;
                # test if any rows left
                if len(dataframe.index) &lt; 1:
                        return False
                # transpose
                df_transposed = dataframe.transpose()
                # add index name
                df_transposed.index.name = subtitle
                # plot
                f = open(filename, &#34;wb&#34;)
                pickle.dump(df_transposed, f)
                f.close()
        def generate(self, numQuery, timer):
                &#34;&#34;&#34;
                Generates a data frame of the benchmark times and saves it to disk as a pickle file.
                Anonymizes dbms if activated.

                :param numQuery: Number of query to generate report of
                :param timer: Timer containing benchmark results
                :return: returns nothing
                &#34;&#34;&#34;
                for t in timer:
                        # are there benchmarks for this query?
                        if not t.checkForSuccessfulBenchmarks(numQuery):
                                continue
                        query = tools.query(self.benchmarker.queries[numQuery-1])
                        # is timer active for this query?
                        if not query.timer[t.name][&#39;active&#39;]:
                                continue
                        # is query active?
                        if not query.active:
                                continue
                        # benchmark times as a datarame
                        df = self.benchmarker.benchmarksToDataFrame(numQuery, t)
                        logging.debug(&#34;Dataframe Q&#34;+str(numQuery)+&#34; for timer &#34;+t.name)
                        # save as plot
                        self.save(
                                dataframe = df,
                                title = &#34;Q&#34;+str(numQuery)+&#34;: Time &#34;+t.name+&#34; [ms]&#34;,
                                subtitle = &#34;Warmup = &#34;+str(query.warmup)+&#34;, test runs = &#34;+str(query.numRun)+&#34;, cooldown = &#34;+str(query.cooldown),
                                filename = self.benchmarker.path+&#39;/query_&#39;+str(numQuery)+&#39;_&#39;+t.name+&#39;_dataframe.pickle&#39;)




class boxploter(reporter):
        &#34;&#34;&#34;
        Class for generating reports.
        Generates a boxplot of the time series and saves it to disk.
        &#34;&#34;&#34;
        def __init__(self, benchmarker):
                reporter.__init__(self, benchmarker)
        def save(self, dataframe, title, filename):
                &#34;&#34;&#34;
                Saves report of a given query as boxplot image per timer.
                Anonymizes dbms if activated.

                :param dataframe: Report data given as a pandas DataFrame (rows=dbms, cols=benchmarks)
                :param title: Title of the report
                :param filename: Name of the file the report will be saved to
                :return: returns nothing
                &#34;&#34;&#34;
                # test if any rows left
                if len(dataframe.index) &lt; 1:
                        return False
                # move index to first column
                dataframe.reset_index(level=0, inplace=True)
                # unpivot
                df_unpivot = pd.melt(dataframe, id_vars=&#39;DBMS&#39;)
                # drop one column
                df_unpivot=df_unpivot.drop(labels=&#39;variable&#39;,axis=1)
                # name columns
                df_unpivot.columns = [&#39;DBMS&#39;, &#39;time [ms]&#39;]
                # anonymize dbms already done
                #df_unpivot[&#39;DBMS&#39;] = df_unpivot[&#39;DBMS&#39;].map(tools.dbms.anonymizer)
                # plot
                boxplot = df_unpivot.boxplot(by=&#39;DBMS&#39;, grid=False)
                # rotate labels
                plt.xticks(rotation=70)
                # align box to labels
                plt.tight_layout()
                # set title and no subtitle
                plt.title(title)
                plt.suptitle(&#34;&#34;)
                # save
                plt.savefig(filename, bbox_inches=&#39;tight&#39;)
                plt.close()
        def generate(self, numQuery, timer):
                &#34;&#34;&#34;
                Generates a boxplot of the time series and saves it to disk.
                Anonymizes dbms if activated.

                :param numQuery: Number of query to generate report of
                :param timer: Timer containing benchmark results
                :return: returns nothing
                &#34;&#34;&#34;
                for t in timer:
                        # are there benchmarks for this query?
                        if not t.checkForSuccessfulBenchmarks(numQuery):
                                continue
                        query = tools.query(self.benchmarker.queries[numQuery-1])
                        # is timer active for this query?
                        if not query.timer[t.name][&#39;active&#39;]:
                                continue
                        # is query active?
                        if not query.active:
                                continue
                        # benchmark times as a dataframe
                        df = self.benchmarker.benchmarksToDataFrame(numQuery, t)
                        logging.debug(&#34;Boxplot Q&#34;+str(numQuery)+&#34; for timer &#34;+t.name)
                        df = df.drop(range(1,query.warmup+1),axis=1)
                        df = df.drop(range(query.numRunEnd+1, query.numRun+1),axis=1)
                        # save as boxplot
                        self.save(
                                dataframe = df,
                                title = &#34;Q&#34;+str(numQuery)+&#34;: Time &#34;+t.name+&#34; [ms] in &#34;+str(len(df.columns))+&#34; test runs&#34;,
                                filename = self.benchmarker.path+&#39;/query_&#39;+str(numQuery)+&#39;_&#39;+t.name+&#39;_boxplot.png&#39;)



class barer(reporter):
        &#34;&#34;&#34;
        Class for generating reports.
        Generates a bar chart of the time series and saves it to disk.
        &#34;&#34;&#34;
        def __init__(self, benchmarker):
                reporter.__init__(self, benchmarker)
        def save(self, dataframe, title, filename):
                &#34;&#34;&#34;
                Saves report of a given query as bar chart image per timer.
                Anonymizes dbms if activated.

                :param dataframe: Report data given as a pandas DataFrame
                :param title: Title of the report
                :param filename: Name of the file the report will be saved to
                :return: returns nothing
                &#34;&#34;&#34;
                # plot
                dataframe.plot.bar(stacked=True)
                # rotate labels
                plt.xticks(rotation=70, fontsize=12)
                # align box to labels
                plt.tight_layout()
                # set title
                plt.legend(title=title)
                # save
                plt.savefig(filename)
                plt.close()
        def generate(self, numQuery, timer, ensembler=&#39;sum&#39;):
                &#34;&#34;&#34;
                Generates a bar chart of the time series and saves it to disk.
                Anonymizes dbms if activated.

                :param numQuery: Number of query to generate report of
                :param timer: Timer containing benchmark results
                :param type: Can be &#39;sum&#39; or &#39;product&#39;
                :return: returns nothing
                &#34;&#34;&#34;
                if ensembler == &#39;sum&#39;:
                        dataframe, title = tools.dataframehelper.sumPerTimer(self.benchmarker, numQuery=numQuery, timer=timer)
                else:
                        dataframe, title = tools.dataframehelper.multiplyPerTimer(self.benchmarker, numQuery=numQuery, timer=timer)
                if dataframe is None:
                        return None
                if numQuery is None:
                        #title = chartlabel+&#34; in &#34;+str(numQueriesEvaluated)+&#34; benchmarks (&#34;+str(numBenchmarks)+&#34; runs) [ms]&#34;
                        filename = self.benchmarker.path+&#39;/total_bar_&#39;+ensembler+&#39;.png&#39;
                else:
                        #title = &#34;Q&#34;+str(numQuery)+&#34;: &#34;+chartlabel+&#34; [ms] in &#34;+str(query.numRun-query.warmup)+&#34; benchmark test runs&#34;
                        filename = self.benchmarker.path+&#39;/query_&#39;+str(numQuery)+&#39;_bar.png&#39;
                print(title)
                print(tabulate(dataframe,headers=dataframe.columns,tablefmt=&#34;grid&#34;, floatfmt=&#34;.2f&#34;))
                # save as boxplot
                self.save(
                        dataframe = dataframe,
                        title = title,
                        filename = filename)
                return dataframe
        def generateAll(self, timer):
                &#34;&#34;&#34;
                Generates all reports for the benchmarker object for a given timer.
                If benchmarker has a fixed query, only reports for this query are generated.
                A plot of the total times is generated in any case.
                Anonymizes dbms if activated.

                :param timer: Timer object
                :return: returns nothing
                &#34;&#34;&#34;
                if not self.benchmarker.fixedQuery is None:
                        self.generate(self.benchmarker.fixedQuery, timer)
                else:
                        if self.benchmarker.bBatch:
                                #range_runs = range(0, query.warmup+query.numRun)
                                range_runs = range(1,len(self.benchmarker.queries)+1)
                        else:
                                #range_runs = tqdm(range(0, query.warmup+query.numRun))
                                range_runs = tqdm(range(1,len(self.benchmarker.queries)+1))
                        for numQuery in range_runs:
                                query = tools.query(self.benchmarker.queries[numQuery-1])
                                # is query active?
                                if not query.active:
                                        continue
                                logging.debug(&#34;Bar Chart Q&#34;+str(numQuery))
                                self.generate(numQuery, timer)
                self.generate(numQuery=None, timer=timer)



class arear(reporter):
        &#34;&#34;&#34;
        Class for generating reports.
        Generates a plot of the benchmarks as a time series and saves it to disk.
        &#34;&#34;&#34;
        def __init__(self, benchmarker):
                reporter.__init__(self, benchmarker)
        def save(self, dataframe, title, subtitle, filename):
                &#34;&#34;&#34;
                Saves report of a given query as plot image per timer.
                Anonymizes dbms if activated.

                :param dataframe: Report data given as a pandas DataFrame (rows=dbms, cols=benchmarks)
                :param title: Title of the report
                :param subtitle: Subtitle of the report
                :param filename: Name of the file the report will be saved to
                :return: returns nothing
                &#34;&#34;&#34;
                # test if any rows left
                if len(dataframe.index) &lt; 1:
                        return False
                # plot
                #plotdata = df_transposed.plot(title=title)
                dataframe.plot.area(title=title)
                # plot
                plt.legend(title=&#34;DBMS&#34;)
                plt.savefig(filename, bbox_inches=&#39;tight&#39;)
                plt.close()
        def generate(self, numQuery, timer):
                &#34;&#34;&#34;
                Generates a plot of the benchmarks as a time series and saves it to disk.
                Anonymizes dbms if activated.

                :param numQuery: Number of query to generate report of
                :param timer: Timer containing benchmark results
                :return: returns nothing
                &#34;&#34;&#34;
                dataframe, title = tools.dataframehelper.totalTimes(self.benchmarker)
                if dataframe is None:
                        return dataframe
                #logging.debug(&#34;Plot Q&#34;+str(numQuery)+&#34; for timer &#34;+t.name)
                if numQuery is None:
                        #title = chartlabel+&#34; in &#34;+str(numQueriesEvaluated)+&#34; benchmarks (&#34;+str(numBenchmarks)+&#34; runs) [ms]&#34;
                        filename = self.benchmarker.path+&#39;/total_time_area.png&#39;
                else:
                        #title = &#34;Q&#34;+str(numQuery)+&#34;: &#34;+chartlabel+&#34; [ms] in &#34;+str(query.numRun-query.warmup)+&#34; benchmark test runs&#34;
                        filename = self.benchmarker.path+&#39;/query_&#39;+str(numQuery)+&#39;_area.png&#39;
                # save as plot
                self.save(
                        dataframe = dataframe,
                        title = &#34;Total times [ms]&#34;,
                        subtitle = &#34;&#34;,
                        filename = filename)
                dataframe.loc[&#39;Total&#39;]= dataframe.sum()
                return dataframe
        def generateAll(self, timer):
                &#34;&#34;&#34;
                Generates all reports for the benchmarker object for a given timer.
                If benchmarker has a fixed query, only reports for this query are generated.
                A plot of the total times is generated in any case.
                Anonymizes dbms if activated.

                :param timer: Timer object
                :return: returns nothing
                &#34;&#34;&#34;
                self.generate(numQuery=None, timer=timer)



class metricer(reporter):
        &#34;&#34;&#34;
        Class for generating reports.
        Generates a plot of the benchmarks as a time series and saves it to disk.
        &#34;&#34;&#34;
        def __init__(self, benchmarker):
                reporter.__init__(self, benchmarker)
        def save(self, dataframe, title, subtitle, filename):
                &#34;&#34;&#34;
                Saves report of a given query as plot image per timer.
                Anonymizes dbms if activated.

                :param dataframe: Report data given as a pandas DataFrame (rows=dbms, cols=benchmarks)
                :param title: Title of the report
                :param subtitle: Subtitle of the report
                :param filename: Name of the file the report will be saved to
                :return: returns nothing
                &#34;&#34;&#34;
                pass
        def generate(self, numQuery, timer):
                &#34;&#34;&#34;
                Generates a plot of the benchmarks as a time series and saves it to disk.
                Anonymizes dbms if activated.

                :param numQuery: Number of query to generate report of
                :param timer: Timer containing benchmark results
                :return: returns nothing
                &#34;&#34;&#34;
                for connectionname, connection in self.benchmarker.dbms.items():
                        if connection.hasHardwareMetrics():
                                logging.debug(&#34;Hardware metrics for Q&#34;+str(numQuery))
                                metricsReporter = monitor.metrics(self.benchmarker)
                                metricsReporter.generatePlotForQuery(numQuery)
                                break
        def generateAll(self, timer):
                &#34;&#34;&#34;
                Generates all reports for the benchmarker object for a given timer.
                If benchmarker has a fixed query, only reports for this query are generated.
                A plot of the total times is generated in any case.
                Anonymizes dbms if activated.

                :param timer: Timer object
                :return: returns nothing
                &#34;&#34;&#34;
                for q, d in self.benchmarker.protocol[&#39;query&#39;].items():
                        query = tools.query(self.benchmarker.queries[int(q)-1])
                        # is query active?
                        if not query.active:
                                continue
                        self.generate(q, [])




class latexer(reporter):
        &#34;&#34;&#34;
        Class for generating reports.
        This class generates a survey in latex and saves it to disk.
        The survey has one page per timer.
        &#34;&#34;&#34;
        def __init__(self, benchmarker, templatefolder=&#34;simple&#34;):
                reporter.__init__(self, benchmarker)
                self.template = {}
                self.templatefolder = templatefolder
                self.readTemplates(templatefolder)
        def readTemplates(self, templatefolder):
                &#34;&#34;&#34;
                Reads content of a template folder

                :param timer: Timer object
                :return: returns nothing
                &#34;&#34;&#34;
                templates = [&#39;reportHead&#39;, &#39;reportFoot&#39;, &#39;query&#39;, &#39;timer&#39;, &#39;appendix&#39;, &#39;appendixquery&#39;, &#39;appendixtimer&#39;]
                for t in templates:
                        with open(&#39;latex/&#39;+templatefolder+&#34;/&#34;+t, &#39;r&#39;) as f:
                                self.template[t]=f.read()
        def useTemplate(self, name, parameter):
                &#34;&#34;&#34;
                Applies parameter to a template and returns filled template

                :param name: Name of the template
                :param parameter: Dict of parameters
                :return: returns template with filled paramter
                &#34;&#34;&#34;
                logging.debug(&#34;useTemplate: &#34;+self.templatefolder+&#34;/&#34;+name)
                return self.template[name].format(**parameter)
        def generateSummary(self):
                &#34;&#34;&#34;
                Generates data for the front page of latex report.

                :return: returns nothing
                &#34;&#34;&#34;
        def init(self):
                &#34;&#34;&#34;
                Generates and saves front page of latex report.

                :return: returns nothing
                &#34;&#34;&#34;
                # generate bar plot of total times
                reporterBar = barer(self.benchmarker)
                dfTotalSum = reporterBar.generate(numQuery=None, timer=self.benchmarker.timers, ensembler=&#39;sum&#39;)
                dfTotalProd = reporterBar.generate(numQuery=None, timer=self.benchmarker.timers, ensembler=&#39;product&#39;)
                # generate area plot of total time
                reporterArea = arear(self.benchmarker)
                dfTotalTime = reporterArea.generate(numQuery=None, timer=self.benchmarker.timers)
                if dfTotalTime is not None:
                        print(tabulate(dfTotalTime,headers=dfTotalTime.columns,tablefmt=&#34;grid&#34;, floatfmt=&#34;.2f&#34;))
                # generate barh plot of total ranking
                dfTotalRank, timers = self.benchmarker.generateSortedTotalRanking()
                #print(title)
                filename = self.benchmarker.path+&#39;/total_barh_rank.png&#39;
                title = &#39;Ranking of &#39;+str(timers)+&#39; timers&#39;
                dfTotalRank.plot.barh()
                plt.xticks(fontsize=14)
                # align box to labels
                plt.tight_layout()
                # set title
                plt.legend(title=title)
                # save
                plt.savefig(filename)
                plt.close()
                print(title)
                print(tabulate(dfTotalRank,headers=dfTotalRank.columns,tablefmt=&#34;grid&#34;, floatfmt=&#34;.2f&#34;))
                if dfTotalSum is not None:
                        dfTotalSum = dfTotalSum.applymap(lambda x: &#39;{:.{prec}f}&#39;.format(x, prec=2))
                if dfTotalProd is not None:
                        dfTotalProd = dfTotalProd.applymap(lambda x: &#39;{:.{prec}f}&#39;.format(x, prec=2))
                dfTotalRank = dfTotalRank.applymap(lambda x: &#39;{:.{prec}f}&#39;.format(x, prec=2))
                # time for ingest
                timesLoad = {}
                for c,cd in self.benchmarker.dbms.items():
                        if cd.connectiondata[&#39;active&#39;] and &#39;timeLoad&#39; in cd.connectiondata: 
                                timesLoad[self.benchmarker.dbms[c].getName()] = cd.connectiondata[&#39;timeLoad&#39;]
                # store in parameter array for replacement in templates
                parameter = self.prepare(0, 0)
                if dfTotalSum is not None:
                        parameter[&#39;totalSum&#39;] = tabulate(dfTotalSum, headers=dfTotalSum.columns, tablefmt=&#34;latex&#34;, floatfmt=&#34;,.2f&#34;, stralign=&#34;right&#34;, showindex=True)
                else:
                        parameter[&#39;totalSum&#39;] = &#34;&#34;
                if dfTotalProd is not None:
                        parameter[&#39;totalProd&#39;] = tabulate(dfTotalProd, headers=dfTotalProd.columns, tablefmt=&#34;latex&#34;, floatfmt=&#34;,.2f&#34;, stralign=&#34;right&#34;, showindex=True)
                else:
                        parameter[&#39;totalProd&#39;] = &#34;&#34;
                parameter[&#39;totalRank&#39;] = tabulate(dfTotalRank, headers=dfTotalRank.columns, tablefmt=&#34;latex&#34;, floatfmt=&#34;,.2f&#34;, stralign=&#34;right&#34;, showindex=True)
                if dfTotalTime is not None:
                        listofnames = [&#39;DBMS &#39;+str(l+1) for l in range(len(dfTotalTime.columns))]
                        dfTotalTimeTranslation = pd.DataFrame(dfTotalTime.columns,index=listofnames,columns=[&#39;DBMS Name&#39;])
                        dfTotalTime.columns = listofnames
                        parameter[&#39;totalTime&#39;] = tabulate(dfTotalTime, headers=dfTotalTime.columns, tablefmt=&#34;latex&#34;, floatfmt=&#34;,.2f&#34;, stralign=&#34;right&#34;, showindex=True)
                        parameter[&#39;totalTime&#39;] += &#34;\\\\&#34;+tabulate(dfTotalTimeTranslation, headers=dfTotalTimeTranslation.columns, tablefmt=&#34;latex&#34;, floatfmt=&#34;,.2f&#34;, stralign=&#34;right&#34;, showindex=True)
                else:
                        parameter[&#39;totalTime&#39;] = &#34;&#34;
                #print(timesLoad)
                if len(timesLoad) &gt; 0:
                        dfIngest = pd.DataFrame.from_dict(timesLoad, orient=&#39;index&#39;)
                        dfIngest.columns=[&#39;Time of Ingestion [s]&#39;]
                        dfIngest.sort_values(by=[&#39;Time of Ingestion [s]&#39;], inplace=True, ascending=False)
                        filename = self.benchmarker.path+&#39;/total_barh_ingest.png&#39;
                        title = &#39;Ingest into &#39;+str(len(dfIngest.index))+&#39; DBMS&#39;
                        dfIngest.plot.barh()
                        plt.xticks(fontsize=14)
                        # align box to labels
                        plt.tight_layout()
                        # set title
                        plt.legend(title=title)
                        # save
                        plt.savefig(filename)
                        plt.close()
                        parameter[&#39;totalIngest&#39;] = tabulate(dfIngest, headers=dfIngest.columns, tablefmt=&#34;latex&#34;, floatfmt=&#34;,.2f&#34;, stralign=&#34;right&#34;, showindex=True)
                else:
                        parameter[&#39;totalIngest&#39;] = &#34;&#34;
                # generate report head
                latex_output = self.useTemplate(&#39;reportHead&#39;, parameter)# self.template[&#39;reportHead&#39;].format(**parameter)
                latex_file = open(self.benchmarker.path+&#34;/benchmarks.tex&#34;, &#34;w&#34;)
                latex_file.write(latex_output)
                latex_file.close()
        def prepare(self, numQuery=0, numTimer=0, timer=None):
                &#34;&#34;&#34;
                Prepares a dict containing data about query and timer.
                This will be used to fill the latex output template.
                Anonymizes dbms if activated.

                :param numQuery: Number of query to collect data from. numQuery=0 for title page
                :param numTimer: Number of timer of this query. First timer is treated differently (subsubsection)
                :param timer: List of timers to collect data from. timer=None for title page
                :return: returns dict of data about query and timer
                &#34;&#34;&#34;
                result = {}
                result[&#39;now&#39;]=str(datetime.datetime.now())
                result[&#39;path&#39;]=self.benchmarker.path
                result[&#39;code&#39;]=self.benchmarker.code
                result[&#39;timeout&#39;]=str(self.benchmarker.timeout)+&#34;s&#34;
                result[&#39;numProcesses&#39;]=self.benchmarker.numProcesses
                result[&#39;runsPerConnection&#39;]=self.benchmarker.runsPerConnection
                if len(self.benchmarker.queryconfig[&#34;intro&#34;]) &gt; 0:
                        result[&#39;intro&#39;] = self.benchmarker.queryconfig[&#34;intro&#34;]+&#34;\\\\&#34;
                # list of active queries for timer #0 = execution
                qs = tools.findSuccessfulQueriesAllDBMS(self.benchmarker, None, self.benchmarker.timers)[0]
                #print(qs)
                # compute total times
                times = {}
                l = list({c for c in {c for q,d in self.benchmarker.protocol[&#39;query&#39;].items() if int(q)-1 in qs for c in d[&#39;durations&#39;].items()}})
                #print(l)
                for i,element in enumerate(l):
                        #print(element)
                        if not element[0] in times:
                                times[element[0]] = element[1]
                        else:
                                times[element[0]] += element[1]
                #print(times)
                # format dbms infos
                def initfilename(c, i):
                        return self.benchmarker.path+&#39;/&#39;+c+&#39;_init_&#39;+str(i)+&#39;.log&#39;
                def hasInitScript(c):
                        return os.path.isfile(initfilename(c,0))
                dbmsinfos = &#34;&#34;
                #for c in sorted(self.benchmarker.dbms.keys()):
                for c in sorted(self.benchmarker.dbms, key=lambda kv: self.benchmarker.dbms[kv].name):
                        if self.benchmarker.dbms[c].connectiondata[&#39;active&#39;]:
                                dbmsdata = self.benchmarker.dbms[c].getName()
                                if not self.benchmarker.anonymize:
                                        dbmsdata += &#34; (&#34;+self.benchmarker.dbms[c].connectiondata[&#34;version&#34;]+&#34;)&#34;
                                dbmsinfos += &#34;\\subsubsection{{{dbmsname}}}&#34;.format(dbmsname=dbmsdata)
                                dbmsinfos += &#34;\\begin{itemize}\n&#34;
                                info = self.benchmarker.dbms[c].connectiondata[&#34;info&#34;]
                                if len(info) &gt; 0:
                                        if not str(info) == info:
                                                dbmsinfos += &#34;\\item &#34;+(&#34;\\item &#34;.join(info))
                                if &#39;connectionmanagement&#39; in self.benchmarker.dbms[c].connectiondata:
                                        connectionmanagement = self.benchmarker.dbms[c].connectiondata[&#39;connectionmanagement&#39;]
                                        if &#34;numProcesses&#34; in connectionmanagement:
                                                dbmsinfos += &#34;\\item \\textbf{Parallel Clients}: &#34;+str(connectionmanagement[&#34;numProcesses&#34;])
                                        if &#34;runsPerConnection&#34; in connectionmanagement:
                                                if connectionmanagement[&#34;runsPerConnection&#34;] &gt; 0:
                                                        dbmsinfos += &#34;\\item \\textbf{Runs per Connection}: &#34;+str(connectionmanagement[&#34;runsPerConnection&#34;])
                                                else:
                                                        dbmsinfos += &#34;\\item \\textbf{Runs per Connection}: Unlimited&#34;
                                        if &#34;timeout&#34; in connectionmanagement:
                                                if connectionmanagement[&#34;timeout&#34;] &gt; 0:
                                                        dbmsinfos += &#34;\\item \\textbf{Timeout}: &#34;+str(connectionmanagement[&#34;timeout&#34;])
                                                else:
                                                        dbmsinfos += &#34;\\item \\textbf{Timeout}: Unlimited&#34;
                                else:
                                        #numProcesses = int(self.benchmarker.dbms[c].connectiondata[&#34;numProcesses&#34;])
                                        #if numProcesses == 0:
                                        numProcesses = int(self.benchmarker.numProcesses)
                                        if not numProcesses == 0:
                                                dbmsinfos += &#34;\\item \\textbf{Clients}: &#34;+str(numProcesses)+&#34; parallel clients&#34;
                                                if self.benchmarker.runsPerConnection &gt; 0:
                                                        dbmsinfos += &#34;\\item \\textbf{Runs per Connection}: &#34;+str(self.benchmarker.runsPerConnection)
                                                else:
                                                        dbmsinfos += &#34;\\item \\textbf{Runs per Connection}: Unlimited&#34;
                                                if self.benchmarker.timeout &gt; 0:
                                                        dbmsinfos += &#34;\\item \\textbf{Timeout}: &#34;+str(self.benchmarker.timeout)
                                                else:
                                                        dbmsinfos += &#34;\\item \\textbf{Timeout}: Unlimited&#34;
                                if &#34;CPU&#34; in self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;]:
                                        dbmsinfos += &#34;\\item \\textbf{CPU}: &#34;+self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;][&#34;CPU&#34;]
                                if &#34;Cores&#34; in self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;]:
                                        dbmsinfos += &#34;\\item \\textbf{Cores}: &#34;+self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;][&#34;Cores&#34;]
                                if &#34;RAM&#34; in self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;]:
                                        dbmsinfos += &#34;\\item \\textbf{RAM}: &#34;+str(self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;][&#34;RAM&#34;])+&#34; GB&#34;
                                if &#34;GPU&#34; in self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;]:
                                        dbmsinfos += &#34;\\item \\textbf{GPU}: &#34;+self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;][&#34;GPU&#34;]
                                if &#34;CUDA&#34; in self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;]:
                                        dbmsinfos += &#34;\\item \\textbf{CUDA}: &#34;+self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;][&#34;CUDA&#34;]
                                if &#34;host&#34; in self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;]:
                                        dbmsinfos += &#34;\\item \\textbf{Host}: &#34;+self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;][&#34;host&#34;]
                                if &#34;disk&#34; in self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;]:
                                        dbmsinfos += &#34;\\item \\textbf{Docker Disk Space Used}: &#34;+self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;][&#34;disk&#34;]
                                if &#34;instance&#34; in self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;]:
                                        dbmsinfos += &#34;\\item \\textbf{Instance}: &#34;+self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;][&#34;instance&#34;]
                                if &#34;timeLoad&#34; in self.benchmarker.dbms[c].connectiondata:
                                        dbmsinfos += &#34;\\item \\textbf{Time Ingest}: &#34;+tools.formatDuration(self.benchmarker.dbms[c].connectiondata[&#34;timeLoad&#34;]*1000.0)
                                if c in times:
                                        dbmsinfos += &#34;\\item \\textbf{Time Benchmarks}: &#34;+tools.formatDuration(times[c])
                                        if &#39;priceperhourdollar&#39; in self.benchmarker.dbms[c].connectiondata:
                                                if &#34;timeLoad&#34; in self.benchmarker.dbms[c].connectiondata:
                                                        time = times[c] + self.benchmarker.dbms[c].connectiondata[&#34;timeLoad&#34;]*1000.0
                                                        dbmsinfos += &#34;\\item \\textbf{Time Total}: &#34;+tools.formatDuration(time)
                                                else:
                                                        time = times[c]
                                                dbmsinfos += &#34;\\item \\textbf{{Price}}: \\${:.{prec}f} (\\${:.{prec}f}/h)&#34;.format(self.benchmarker.dbms[c].connectiondata[&#39;priceperhourdollar&#39;]*time/3600000, self.benchmarker.dbms[c].connectiondata[&#39;priceperhourdollar&#39;], prec=2)
                                if hasInitScript(c) and not self.benchmarker.dbms[c].anonymous:
                                        dbmsinfos += &#34;\\item\\hyperref[initscript:{dbms}]{{Initialisation scripts}}&#34;.format(dbms=c)
                                #dbmsinfos += &#34;\\item {}\n&#34;.format(info)
                                #dbmsinfos += &#34;\\item \\textbf{{{}}}: {}\n&#34;.format(dbmsdata, info)
                                dbmsinfos += &#34;\\end{itemize}&#34;
                result[&#39;dbmsinfos&#39;] = dbmsinfos
                # appendix start: query survey
                result[&#39;querySurvey&#39;] = &#39;&#39;
                for i in range(1, len(self.benchmarker.queries)+1):
                        queryObject = tools.query(self.benchmarker.queries[i-1])
                        result[&#39;querySurvey&#39;] += &#34;\n\\\\\\noindent\\hyperref[benchmark:{code}-Q{queryNumber}]{{\\textbf{{Q{queryNumber}: {queryTitle}}}}}\n&#34;.format(code=self.benchmarker.code, queryNumber=i, queryTitle=queryObject.title)
                        if not queryObject.active:
                                result[&#39;querySurvey&#39;] += &#39;\\\\inactive&#39;
                                continue
                        if len(self.benchmarker.protocol[&#39;query&#39;][str(i)][&#39;parameter&#39;]) &gt; 0:
                                result[&#39;querySurvey&#39;] += &#34;\\\\\\hyperref[parameter:{code}-Q{queryNumber}]{{Parametrized}}&#34;.format(**result, queryNumber=i)
                        l = self.benchmarker.protocol[&#39;query&#39;][str(i)][&#39;dataStorage&#39;]
                        if len(l) &gt; 0 and len(l[0]) &gt; 0 and len(l[0][0]) &gt; 0:
                                l = [x for l1 in l for l2 in l1 for x in l2]
                                result[&#39;querySurvey&#39;] += &#34;\\\\\\hyperref[data:{code}-Q{queryNumber}]{{Storage size}}: &#34;.format(**result, queryNumber=i)+str(sys.getsizeof(l))+&#34; bytes (&#34;+queryObject.result+&#34;)&#34;
                        for connection, error in self.benchmarker.protocol[&#39;query&#39;][str(i)][&#39;errors&#39;].items():
                                if len(error) &gt; 0 and self.benchmarker.dbms[connection].connectiondata[&#39;active&#39;]:
                                        result[&#39;querySurvey&#39;] += &#34;\\\\\\noindent &#34;+self.benchmarker.dbms[connection].getName()+&#34;: {\\textit{\\error{&#34;+tools.tex_escape(error)+&#34;}}}\n&#34;
                                        #result[&#39;querySurvey&#39;] += &#34;\\\\\\noindent &#34;+connection+&#34;: {\\tiny{\\begin{verbatim}&#34;+error+&#34;\\end{verbatim}}}\n&#34;
                                        #result[&#39;querySurvey&#39;] += &#34;\\\\&#34;+connection+&#34;: Error&#34;
                        for connection, size in self.benchmarker.protocol[&#39;query&#39;][str(i)][&#39;sizes&#39;].items():
                                if size &gt; 0 and self.benchmarker.dbms[connection].connectiondata[&#39;active&#39;]:
                                        result[&#39;querySurvey&#39;] += &#34;\\\\\\noindent &#34;+self.benchmarker.dbms[connection].getName()+&#34;: Received data = &#34;+tools.sizeof_fmt(size)+&#34;\n&#34;
                                        #result[&#39;querySurvey&#39;] += &#34;\\\\&#34;+connection+&#34;: Error&#34;
                #print(result[&#39;querySurvey&#39;])
                # format title of benchmark
                if len(self.benchmarker.queryconfig[&#34;name&#34;]) &gt; 0:
                        benchmarkName = self.benchmarker.queryconfig[&#34;name&#34;]
                else:
                        benchmarkName = self.benchmarker.path
                # if no query: title is section
                if numQuery == 0:
                        benchmarkName = &#39;\\section{%s}&#39; % (benchmarkName)
                result[&#39;benchmarkName&#39;] = benchmarkName
                summary = &#34;&#34;
                numShownPlots = 0
                for i,q in enumerate(self.benchmarker.queries):
                        if self.benchmarker.timerExecution.checkForSuccessfulBenchmarks(i+1):
                                query = tools.query(q)
                                if not query.active:
                                        #print(&#34;skip&#34;)
                                        continue
                                numShownPlots = numShownPlots + 1
                                summary += &#34;&#34;&#34;\\begin{{minipage}}[t]{{0.45\\textwidth}}
\\hyperref[benchmark:{code}-Q{queryNumber}]{{\\textbf{{Q{queryNumber}: {queryTitle}}}}}\\\\
\\includegraphics[height=0.8\\textwidth]{{query_{queryNumber}_bar.png}}
\\end{{minipage}}\n&#34;&#34;&#34;.format(code=self.benchmarker.code, path=self.benchmarker.path, queryNumber=i+1, queryTitle=query.title)
                                if i+1 &lt; len(self.benchmarker.queries) and (numShownPlots)%2:
                                        summary += &#34;\\hfill&#34;
                result[&#39;summary&#39;] = summary
                # init scripts
                result[&#39;initscript&#39;] = &#34;&#34;
                for c in self.benchmarker.dbms:
                        i = 0
                        if hasInitScript(c) and self.benchmarker.dbms[c].connectiondata[&#39;active&#39;] and not self.benchmarker.dbms[c].anonymous:
                                result[&#39;initscript&#39;] += &#34;\\newpage\n\\subsection{{Initscript {dbms}}}\\label{{initscript:{dbms}}}\n&#34;.format(dbms=c)
                                #result[&#39;initscript&#39;] += &#34;\\begin{figure}[h]\\centering\n
                                result[&#39;initscript&#39;] += &#34;\\begin{sqlFormatSmall}\n&#34;
                                while True:
                                        filename=initfilename(c,i)
                                        if os.path.isfile(filename):
                                                result[&#39;initscript&#39;] += open(filename).read()
                                                i = i + 1
                                        else:
                                                break
                                result[&#39;initscript&#39;] += &#34;\n\\end{sqlFormatSmall}\n&#34;
                                #result[&#39;initscript&#39;] += &#34;\\caption{{Init script {dbms}}}\\end{{figure}}&#34;.format(dbms=c)
                # are there benchmarks for this query?
                if numQuery &gt; 0 and self.benchmarker.timerExecution.checkForSuccessfulBenchmarks(numQuery):
                        result[&#39;queryNumber&#39;]=numQuery
                        query = tools.query(self.benchmarker.queries[numQuery-1])
                        # format duration
                        result[&#39;duration&#39;] = tools.formatDuration(self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;duration&#39;])
                        result[&#39;durations&#39;] = &#34;\\begin{itemize}\n&#34;
                        for c, d in self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;durations&#39;].items():
                                result[&#39;durations&#39;] += &#39;\\item\\textbf{&#39;+self.benchmarker.dbms[c].getName()+&#39;}: &#39;+tools.formatDuration(d)+&#39;\n&#39;
                        result[&#39;durations&#39;] += &#34;\\end{itemize}\n&#34;
                        # format errors
                        errors = &#39;&#39;
                        for key, value in self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;errors&#39;].items():
                                if not self.benchmarker.dbms[key].connectiondata[&#39;active&#39;]:
                                        continue
                                if len(value) &gt; 0:
                                        #firstpos = value.find(&#39;: &#39;)
                                        #if firstpos &gt; 0:
                                        #       #errors += &#39;\\\\&#39;+self.benchmarker.dbms[key].getName() + &#39;: \\verb|&#39; + value[(firstpos+2):] + &#39;|\\\\&#39;
                                        #       errors += &#39;\\\\&#39;+self.benchmarker.dbms[key].getName() + &#39;: \\error{&#39; + tools.tex_escape(value[(firstpos+2):]) + &#39;}\\\\&#39;
                                        #else:
                                        #       #errors += &#39;\\\\&#39;+self.benchmarker.dbms[key].getName() + &#39;: \\verb|&#39; + value + &#39;|\\\\&#39;
                                        #       errors += &#39;\\\\&#39;+self.benchmarker.dbms[key].getName() + &#39;: \\error{&#39; + tools.tex_escape(value) + &#39;}\\\\&#39;
                                        errors += &#39;\\\\&#39;+self.benchmarker.dbms[key].getName() + &#39;: \\error{&#39; + tools.tex_escape(value) + &#39;}\\\\&#39;
                        if len(errors) &gt; 0:
                                errors = &#39;\\subsubsection{{Error}}\\label{{error:{code}-Q{queryNumber}}}&#39;.format(**result)+errors
                        errors += &#39;&#39;
                        result[&#39;errors&#39;] = errors
                        # format parameter
                        parameter = &#39;&#39;
                        showParameter = self.benchmarker.queryconfig[&#34;reporting&#34;][&#34;queryparameter&#34;]
                        if showParameter:
                                if len(self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;parameter&#39;]) &gt; 0:
                                        parameter += &#39;\\subsubsection{{Parameter}}\\label{{parameter:{code}-Q{queryNumber}}}&#39;.format(**result)
                                        #parameter += &#39;\\subsubsection{Parameter}&#39;
                                        listParameter = self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;parameter&#39;]
                                        dataframeParameter = pd.DataFrame.from_records(listParameter)
                                        dataframeParameter.index=range(1,len(listParameter)+1)
                                        if showParameter == &#39;first&#39;:
                                                dataframeParameter = dataframeParameter.iloc[0:1, :]
                                        parameter += tabulate(dataframeParameter, headers=dataframeParameter.columns, tablefmt=&#34;latex&#34;, stralign=&#34;right&#34;, showindex=True)
                                        parameter += &#39;\\\\&#39;
                        result[&#39;queryParameter&#39;] = parameter
                        # data
                        result[&#39;data&#39;] = &#34;&#34;
                        showStorage = self.benchmarker.queryconfig[&#34;reporting&#34;][&#34;resultsetPerQuery&#34;]
                        if self.benchmarker.queryconfig[&#34;reporting&#34;][&#34;resultsetPerQuery&#34;]:
                                #print(&#34;resultsetPerQuery&#34;)
                                if not self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;dataStorage&#39;] is None:
                                        result[&#39;data&#39;] += &#39;\\subsubsection{{Received Data}}\\label{{data:{code}-Q{queryNumber}}}&#39;.format(**result)
                                        for i,data in enumerate(self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;dataStorage&#39;]):
                                                if data is not None and len(data) &gt; 0:
                                                        df = pd.DataFrame.from_records(data)
                                                        # first row contains column names
                                                        df.columns = df.iloc[0]
                                                        # remove first row
                                                        df = df[1:]
                                                        if query.result == &#39;result&#39;:
                                                                result[&#39;data&#39;] += &#34;\\noindent\\textbf{Result table of run &#34;+str(i+1)+&#34;}:\\\\&#34;
                                                        elif query.result == &#39;hash&#39;:
                                                                result[&#39;data&#39;] += &#34;\\noindent\\textbf{Result hash of run &#34;+str(i+1)+&#34;}:\\\\&#34;
                                                        elif query.result == &#39;size&#39;:
                                                                result[&#39;data&#39;] += &#34;\\noindent\\textbf{Result size of run &#34;+str(i+1)+&#34;}:\\\\&#34;
                                                        if query.restrict_precision:
                                                                precision = query.restrict_precision
                                                        else:
                                                                precision = 2
                                                        if df.empty:
                                                                df.loc[len(df), :] = [&#39;-&#39; for i in range(1,len(df.columns)+1)]
                                                        result[&#39;data&#39;] += tabulate(df, headers=df.columns, tablefmt=&#34;latex&#34;, stralign=&#34;right&#34;, floatfmt=&#34;,.&#34;+str(precision)+&#34;f&#34;, showindex=False)
                                                        result[&#39;data&#39;] += &#39;\\\\\n\n&#39;
                                                        if showStorage == &#34;first&#34;:
                                                                break;
                        # result sets
                        result[&#39;resultSets&#39;] = &#34;&#34;
                        showResultsets = self.benchmarker.queryconfig[&#34;reporting&#34;][&#34;resultsetPerQueryConnection&#34;]
                        if showResultsets:
                                #print(&#34;resultsetPerQueryConnection&#34;)
                                if not self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;resultSets&#39;] is None:
                                        for c, sets in self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;resultSets&#39;].items():
                                                if len(sets) &gt; 0:
                                                        # show result set because there is an error
                                                        result[&#39;resultSets&#39;] += &#39;\\subsubsection{Received Data of &#39;+self.benchmarker.dbms[c].getName()+&#39;}&#39;
                                                        for i, data in enumerate(sets):
                                                                if data is not None and len(data) &gt; 0:
                                                                        if showResultsets == &#34;differing&#34;:
                                                                                # only show result sets differing from data storage
                                                                                if len(self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;dataStorage&#39;]) &gt; i:
                                                                                        if self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;dataStorage&#39;][i] == self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;resultSets&#39;][c][i]:
                                                                                                #print(&#34;Same result for run &#34;+str(i)+&#34; of query &#34;+str(numQuery))
                                                                                                continue
                                                                                else:
                                                                                        if self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;dataStorage&#39;][0] == self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;resultSets&#39;][c][i]:
                                                                                                #print(&#34;Same result for run &#34;+str(i)+&#34; of query &#34;+str(numQuery))
                                                                                                continue
                                                                        df = pd.DataFrame.from_records(data)
                                                                        # first row contains column names
                                                                        df.columns = df.iloc[0]
                                                                        # remove first row
                                                                        df = df[1:]
                                                                        if query.result == &#39;result&#39;:
                                                                                result[&#39;resultSets&#39;] += &#34;\\noindent\\textbf{Result table of run &#34;+str(i+1)+&#34;}:\\\\&#34;
                                                                        elif query.result == &#39;hash&#39;:
                                                                                result[&#39;resultSets&#39;] += &#34;\\noindent\\textbf{Result hash of run &#34;+str(i+1)+&#34;}:\\\\&#34;
                                                                        elif query.result == &#39;size&#39;:
                                                                                result[&#39;resultSets&#39;] += &#34;\\noindent\\textbf{Result size of run &#34;+str(i+1)+&#34;}:\\\\&#34;
                                                                        if query.restrict_precision:
                                                                                precision = query.restrict_precision
                                                                        else:
                                                                                precision = 2
                                                                        if df.empty:
                                                                                df.loc[len(df), :] = [&#39;-&#39; for i in range(1,len(df.columns)+1)]
                                                                        result[&#39;resultSets&#39;] += tabulate(df, headers=df.columns, tablefmt=&#34;latex&#34;, stralign=&#34;right&#34;, floatfmt=&#34;,.&#34;+str(precision)+&#34;f&#34;, showindex=False)
                                                                        result[&#39;resultSets&#39;] += &#39;\\\\\n\n&#39;
                                                                        if showResultsets == &#34;first&#34;:
                                                                                break;
                        # format title of query
                        queryName = &#39;Query %d%s&#39; % (numQuery, &#39;: &#39;+query.title)
                        result[&#39;queryName&#39;] = queryName
                        result[&#39;queryString&#39;] = query.query
                        queryNotes = &#34;&#34;
                        for c in query.DBMS:
                                for connectionname, connection in self.benchmarker.dbms.items():
                                        if connectionname.startswith(c) and self.benchmarker.dbms[connectionname].connectiondata[&#39;active&#39;]:
                                                queryNotes += self.benchmarker.dbms[connectionname].getName() + &#39;: Different query\n\\begin{sqlFormat}\n&#39; + query.DBMS[c] + &#39;\n\\end{sqlFormat}&#39;
                        result[&#39;queryNotes&#39;] = queryNotes
                        result[&#39;warmup&#39;]=str(query.warmup)
                        result[&#39;cooldown&#39;]=str(query.cooldown)
                        result[&#39;run&#39;]=str(query.numRun)
                        result[&#39;start&#39;]=self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;start&#39;]
                        result[&#39;end&#39;]=self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;end&#39;]
                        # hardware metrics
                        result[&#39;hardwareMetrics&#39;] = &#34;&#34;
                        for connectionname, connection in self.benchmarker.dbms.items():
                                if self.benchmarker.dbms[connectionname].hasHardwareMetrics():
                                        metricsReporter = monitor.metrics(self.benchmarker)
                                        #result[&#39;hardwareMetrics&#39;] = monitor.metrics.latex.format(**result)
                                        result[&#39;hardwareMetrics&#39;] = metricsReporter.generateLatexForQuery(result)
                                        break
                        # report per timer
                        if numTimer &gt; 0:
                                result[&#39;nameTimer&#39;] = timer.name
                                # format times for output
                                header = tools.timer.header_stats.copy()
                                # add factor column
                                header.insert(1,&#34;factor&#34;)
                                # convert to DataFrame
                                dataframe = self.benchmarker.statsToDataFrame(numQuery, timer)
                                # test if any rows left
                                if dataframe.empty:
                                        return {}
                                # print transfer table in latex
                                table = tabulate(dataframe,headers=header, tablefmt=&#34;latex&#34;, stralign=&#34;right&#34;, floatfmt=&#34;,.2f&#34;, showindex=True)
                                # align dbms name to the left
                                table = table.replace(&#39;\\begin{tabular}{r&#39;, &#39;\\begin{tabular}{l&#39;)
                                result[&#39;table&#39;] = table
                                result[&#39;tableName&#39;] = &#34;Time &#34;+timer.name
                                result[&#39;timerName&#39;] = timer.name
                #print(result)
                return result
        def generate(self, numQuery, timer):
                &#34;&#34;&#34;
                Generates latex report (no front page, given query) for given list of timers.
                Anonymizes dbms if activated.

                :param numQuery: Number of query to collect data from. numQuery=0 for title page
                :param timer: List of timers to collect data from. timer=None for title page
                :return: returns nothing
                &#34;&#34;&#34;
                # generate report pages per started query
                for numQuery in range(1, len(self.benchmarker.queries)+1):
                        # are there benchmarks for this query?
                        if not self.benchmarker.timerExecution.checkForSuccessfulBenchmarks(numQuery):
                                continue
                        # is this query active?
                        query = tools.query(self.benchmarker.queries[numQuery-1])
                        if not query.active:
                                continue
                        parameter = self.prepare(numQuery, 0)
                        latex_output = self.useTemplate(&#39;query&#39;, parameter)
                        for numTimer,t in enumerate(timer):
                                if not t.checkForSuccessfulBenchmarks(numQuery):
                                        continue
                                # is timer active for this query?
                                if not query.timer[t.name][&#39;active&#39;]:
                                        continue
                                parameter = self.prepare(numQuery, numTimer+1, t)
                                if len(parameter) &gt; 0:
                                        latex_output += self.useTemplate(&#39;timer&#39;, parameter)
                        # save latex in file, append to existing
                        latex_file = open(self.benchmarker.path+&#34;/benchmarks.tex&#34;, &#34;a+&#34;)
                        latex_file.write(latex_output)
                        latex_file.close()
                # generate report appendix pages per started query
                parameter = self.prepare(0, 0)
                latex_output = self.useTemplate(&#39;appendix&#39;, parameter)
                latex_file = open(self.benchmarker.path+&#34;/benchmarks.tex&#34;, &#34;a+&#34;)
                latex_file.write(latex_output)
                latex_file.close()
                for numQuery in range(1, len(self.benchmarker.queries)+1):
                        # are there benchmarks for this query?
                        if not self.benchmarker.timerExecution.checkForSuccessfulBenchmarks(numQuery):
                                continue
                        # is this query active?
                        query = tools.query(self.benchmarker.queries[numQuery-1])
                        if not query.active:
                                continue
                        parameter = self.prepare(numQuery, 0)
                        latex_output = self.useTemplate(&#39;appendixquery&#39;, parameter)
                        for numTimer,t in enumerate(timer):
                                if not t.checkForSuccessfulBenchmarks(numQuery):
                                        continue
                                parameter = self.prepare(numQuery, numTimer+1, t)
                                if len(parameter) &gt; 0:
                                        latex_output += self.useTemplate(&#39;appendixtimer&#39;, parameter) #self.template[&#39;timer&#39;].format(**parameter)
                        # save latex in file, append to existing
                        latex_file = open(self.benchmarker.path+&#34;/benchmarks.tex&#34;, &#34;a+&#34;)
                        latex_file.write(latex_output)
                        latex_file.close()
                # generate foot of report
                latex_output = self.useTemplate(&#39;reportFoot&#39;, parameter)
                # save latex in file, append to existing
                latex_file = open(self.benchmarker.path+&#34;/benchmarks.tex&#34;, &#34;a+&#34;)
                latex_file.write(latex_output)
                latex_file.close()
        def generateAll(self, timer):
                &#34;&#34;&#34;
                Generates complete latex report (front page, all queries and connections) for given list of timers.
                Anonymizes dbms if activated.

                :param timer: List of timer objects
                &#34;&#34;&#34;
                self.init()
                self.generate(1, timer)



class latexerPagePerQuery(latexer):
        &#34;&#34;&#34;
        Class for generating reports.
        This class generates a survey in latex and saves it to disk.
        The survey has one page per timer.
        &#34;&#34;&#34;
        def __init__(self, benchmarker, templatefolder):
                latexer.__init__(self, benchmarker, templatefolder=&#34;pagePerQuery&#34;)



class latexerCustom(latexer):
        &#34;&#34;&#34;
        Class for generating reports.
        This class generates a survey in latex and saves it to disk.
        This is a dummy for generating custom reports.
        Concept: Just change the output templates and possibly the prepare method to append/change the results list.
        &#34;&#34;&#34;
        def __init__(self, benchmarker):
                latexer.__init__(self, benchmarker, templatefolder=&#34;custom&#34;)
        def prepare(self, numQuery=0, numTimer=0, timer=None):
                result = latexer.prepare(numQuery, numTimer, timer)
                return result</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dbmsbenchmarker.reporter.arear"><code class="flex name class">
<span>class <span class="ident">arear</span></span>
<span>(</span><span>benchmarker)</span>
</code></dt>
<dd>
<section class="desc"><p>Class for generating reports.
Generates a plot of the benchmarks as a time series and saves it to disk.</p>
<p>Construct a new 'reporter' object.</p>
<p>:param benchmarker: Object of benchmarker containing information about queries, connections and benchmark times
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class arear(reporter):
        &#34;&#34;&#34;
        Class for generating reports.
        Generates a plot of the benchmarks as a time series and saves it to disk.
        &#34;&#34;&#34;
        def __init__(self, benchmarker):
                reporter.__init__(self, benchmarker)
        def save(self, dataframe, title, subtitle, filename):
                &#34;&#34;&#34;
                Saves report of a given query as plot image per timer.
                Anonymizes dbms if activated.

                :param dataframe: Report data given as a pandas DataFrame (rows=dbms, cols=benchmarks)
                :param title: Title of the report
                :param subtitle: Subtitle of the report
                :param filename: Name of the file the report will be saved to
                :return: returns nothing
                &#34;&#34;&#34;
                # test if any rows left
                if len(dataframe.index) &lt; 1:
                        return False
                # plot
                #plotdata = df_transposed.plot(title=title)
                dataframe.plot.area(title=title)
                # plot
                plt.legend(title=&#34;DBMS&#34;)
                plt.savefig(filename, bbox_inches=&#39;tight&#39;)
                plt.close()
        def generate(self, numQuery, timer):
                &#34;&#34;&#34;
                Generates a plot of the benchmarks as a time series and saves it to disk.
                Anonymizes dbms if activated.

                :param numQuery: Number of query to generate report of
                :param timer: Timer containing benchmark results
                :return: returns nothing
                &#34;&#34;&#34;
                dataframe, title = tools.dataframehelper.totalTimes(self.benchmarker)
                if dataframe is None:
                        return dataframe
                #logging.debug(&#34;Plot Q&#34;+str(numQuery)+&#34; for timer &#34;+t.name)
                if numQuery is None:
                        #title = chartlabel+&#34; in &#34;+str(numQueriesEvaluated)+&#34; benchmarks (&#34;+str(numBenchmarks)+&#34; runs) [ms]&#34;
                        filename = self.benchmarker.path+&#39;/total_time_area.png&#39;
                else:
                        #title = &#34;Q&#34;+str(numQuery)+&#34;: &#34;+chartlabel+&#34; [ms] in &#34;+str(query.numRun-query.warmup)+&#34; benchmark test runs&#34;
                        filename = self.benchmarker.path+&#39;/query_&#39;+str(numQuery)+&#39;_area.png&#39;
                # save as plot
                self.save(
                        dataframe = dataframe,
                        title = &#34;Total times [ms]&#34;,
                        subtitle = &#34;&#34;,
                        filename = filename)
                dataframe.loc[&#39;Total&#39;]= dataframe.sum()
                return dataframe
        def generateAll(self, timer):
                &#34;&#34;&#34;
                Generates all reports for the benchmarker object for a given timer.
                If benchmarker has a fixed query, only reports for this query are generated.
                A plot of the total times is generated in any case.
                Anonymizes dbms if activated.

                :param timer: Timer object
                :return: returns nothing
                &#34;&#34;&#34;
                self.generate(numQuery=None, timer=timer)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbmsbenchmarker.reporter.reporter" href="#dbmsbenchmarker.reporter.reporter">reporter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dbmsbenchmarker.reporter.arear.generate"><code class="name flex">
<span>def <span class="ident">generate</span></span>(<span>self, numQuery, timer)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates a plot of the benchmarks as a time series and saves it to disk.
Anonymizes dbms if activated.</p>
<p>:param numQuery: Number of query to generate report of
:param timer: Timer containing benchmark results
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def generate(self, numQuery, timer):
        &#34;&#34;&#34;
        Generates a plot of the benchmarks as a time series and saves it to disk.
        Anonymizes dbms if activated.

        :param numQuery: Number of query to generate report of
        :param timer: Timer containing benchmark results
        :return: returns nothing
        &#34;&#34;&#34;
        dataframe, title = tools.dataframehelper.totalTimes(self.benchmarker)
        if dataframe is None:
                return dataframe
        #logging.debug(&#34;Plot Q&#34;+str(numQuery)+&#34; for timer &#34;+t.name)
        if numQuery is None:
                #title = chartlabel+&#34; in &#34;+str(numQueriesEvaluated)+&#34; benchmarks (&#34;+str(numBenchmarks)+&#34; runs) [ms]&#34;
                filename = self.benchmarker.path+&#39;/total_time_area.png&#39;
        else:
                #title = &#34;Q&#34;+str(numQuery)+&#34;: &#34;+chartlabel+&#34; [ms] in &#34;+str(query.numRun-query.warmup)+&#34; benchmark test runs&#34;
                filename = self.benchmarker.path+&#39;/query_&#39;+str(numQuery)+&#39;_area.png&#39;
        # save as plot
        self.save(
                dataframe = dataframe,
                title = &#34;Total times [ms]&#34;,
                subtitle = &#34;&#34;,
                filename = filename)
        dataframe.loc[&#39;Total&#39;]= dataframe.sum()
        return dataframe</code></pre>
</details>
</dd>
<dt id="dbmsbenchmarker.reporter.arear.generateAll"><code class="name flex">
<span>def <span class="ident">generateAll</span></span>(<span>self, timer)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates all reports for the benchmarker object for a given timer.
If benchmarker has a fixed query, only reports for this query are generated.
A plot of the total times is generated in any case.
Anonymizes dbms if activated.</p>
<p>:param timer: Timer object
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def generateAll(self, timer):
        &#34;&#34;&#34;
        Generates all reports for the benchmarker object for a given timer.
        If benchmarker has a fixed query, only reports for this query are generated.
        A plot of the total times is generated in any case.
        Anonymizes dbms if activated.

        :param timer: Timer object
        :return: returns nothing
        &#34;&#34;&#34;
        self.generate(numQuery=None, timer=timer)</code></pre>
</details>
</dd>
<dt id="dbmsbenchmarker.reporter.arear.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, dataframe, title, subtitle, filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Saves report of a given query as plot image per timer.
Anonymizes dbms if activated.</p>
<p>:param dataframe: Report data given as a pandas DataFrame (rows=dbms, cols=benchmarks)
:param title: Title of the report
:param subtitle: Subtitle of the report
:param filename: Name of the file the report will be saved to
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def save(self, dataframe, title, subtitle, filename):
        &#34;&#34;&#34;
        Saves report of a given query as plot image per timer.
        Anonymizes dbms if activated.

        :param dataframe: Report data given as a pandas DataFrame (rows=dbms, cols=benchmarks)
        :param title: Title of the report
        :param subtitle: Subtitle of the report
        :param filename: Name of the file the report will be saved to
        :return: returns nothing
        &#34;&#34;&#34;
        # test if any rows left
        if len(dataframe.index) &lt; 1:
                return False
        # plot
        #plotdata = df_transposed.plot(title=title)
        dataframe.plot.area(title=title)
        # plot
        plt.legend(title=&#34;DBMS&#34;)
        plt.savefig(filename, bbox_inches=&#39;tight&#39;)
        plt.close()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dbmsbenchmarker.reporter.reporter" href="#dbmsbenchmarker.reporter.reporter">reporter</a></b></code>:
<ul class="hlist">
<li><code><a title="dbmsbenchmarker.reporter.reporter.init" href="#dbmsbenchmarker.reporter.reporter.init">init</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="dbmsbenchmarker.reporter.barer"><code class="flex name class">
<span>class <span class="ident">barer</span></span>
<span>(</span><span>benchmarker)</span>
</code></dt>
<dd>
<section class="desc"><p>Class for generating reports.
Generates a bar chart of the time series and saves it to disk.</p>
<p>Construct a new 'reporter' object.</p>
<p>:param benchmarker: Object of benchmarker containing information about queries, connections and benchmark times
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class barer(reporter):
        &#34;&#34;&#34;
        Class for generating reports.
        Generates a bar chart of the time series and saves it to disk.
        &#34;&#34;&#34;
        def __init__(self, benchmarker):
                reporter.__init__(self, benchmarker)
        def save(self, dataframe, title, filename):
                &#34;&#34;&#34;
                Saves report of a given query as bar chart image per timer.
                Anonymizes dbms if activated.

                :param dataframe: Report data given as a pandas DataFrame
                :param title: Title of the report
                :param filename: Name of the file the report will be saved to
                :return: returns nothing
                &#34;&#34;&#34;
                # plot
                dataframe.plot.bar(stacked=True)
                # rotate labels
                plt.xticks(rotation=70, fontsize=12)
                # align box to labels
                plt.tight_layout()
                # set title
                plt.legend(title=title)
                # save
                plt.savefig(filename)
                plt.close()
        def generate(self, numQuery, timer, ensembler=&#39;sum&#39;):
                &#34;&#34;&#34;
                Generates a bar chart of the time series and saves it to disk.
                Anonymizes dbms if activated.

                :param numQuery: Number of query to generate report of
                :param timer: Timer containing benchmark results
                :param type: Can be &#39;sum&#39; or &#39;product&#39;
                :return: returns nothing
                &#34;&#34;&#34;
                if ensembler == &#39;sum&#39;:
                        dataframe, title = tools.dataframehelper.sumPerTimer(self.benchmarker, numQuery=numQuery, timer=timer)
                else:
                        dataframe, title = tools.dataframehelper.multiplyPerTimer(self.benchmarker, numQuery=numQuery, timer=timer)
                if dataframe is None:
                        return None
                if numQuery is None:
                        #title = chartlabel+&#34; in &#34;+str(numQueriesEvaluated)+&#34; benchmarks (&#34;+str(numBenchmarks)+&#34; runs) [ms]&#34;
                        filename = self.benchmarker.path+&#39;/total_bar_&#39;+ensembler+&#39;.png&#39;
                else:
                        #title = &#34;Q&#34;+str(numQuery)+&#34;: &#34;+chartlabel+&#34; [ms] in &#34;+str(query.numRun-query.warmup)+&#34; benchmark test runs&#34;
                        filename = self.benchmarker.path+&#39;/query_&#39;+str(numQuery)+&#39;_bar.png&#39;
                print(title)
                print(tabulate(dataframe,headers=dataframe.columns,tablefmt=&#34;grid&#34;, floatfmt=&#34;.2f&#34;))
                # save as boxplot
                self.save(
                        dataframe = dataframe,
                        title = title,
                        filename = filename)
                return dataframe
        def generateAll(self, timer):
                &#34;&#34;&#34;
                Generates all reports for the benchmarker object for a given timer.
                If benchmarker has a fixed query, only reports for this query are generated.
                A plot of the total times is generated in any case.
                Anonymizes dbms if activated.

                :param timer: Timer object
                :return: returns nothing
                &#34;&#34;&#34;
                if not self.benchmarker.fixedQuery is None:
                        self.generate(self.benchmarker.fixedQuery, timer)
                else:
                        if self.benchmarker.bBatch:
                                #range_runs = range(0, query.warmup+query.numRun)
                                range_runs = range(1,len(self.benchmarker.queries)+1)
                        else:
                                #range_runs = tqdm(range(0, query.warmup+query.numRun))
                                range_runs = tqdm(range(1,len(self.benchmarker.queries)+1))
                        for numQuery in range_runs:
                                query = tools.query(self.benchmarker.queries[numQuery-1])
                                # is query active?
                                if not query.active:
                                        continue
                                logging.debug(&#34;Bar Chart Q&#34;+str(numQuery))
                                self.generate(numQuery, timer)
                self.generate(numQuery=None, timer=timer)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbmsbenchmarker.reporter.reporter" href="#dbmsbenchmarker.reporter.reporter">reporter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dbmsbenchmarker.reporter.barer.generate"><code class="name flex">
<span>def <span class="ident">generate</span></span>(<span>self, numQuery, timer, ensembler='sum')</span>
</code></dt>
<dd>
<section class="desc"><p>Generates a bar chart of the time series and saves it to disk.
Anonymizes dbms if activated.</p>
<p>:param numQuery: Number of query to generate report of
:param timer: Timer containing benchmark results
:param type: Can be 'sum' or 'product'
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def generate(self, numQuery, timer, ensembler=&#39;sum&#39;):
        &#34;&#34;&#34;
        Generates a bar chart of the time series and saves it to disk.
        Anonymizes dbms if activated.

        :param numQuery: Number of query to generate report of
        :param timer: Timer containing benchmark results
        :param type: Can be &#39;sum&#39; or &#39;product&#39;
        :return: returns nothing
        &#34;&#34;&#34;
        if ensembler == &#39;sum&#39;:
                dataframe, title = tools.dataframehelper.sumPerTimer(self.benchmarker, numQuery=numQuery, timer=timer)
        else:
                dataframe, title = tools.dataframehelper.multiplyPerTimer(self.benchmarker, numQuery=numQuery, timer=timer)
        if dataframe is None:
                return None
        if numQuery is None:
                #title = chartlabel+&#34; in &#34;+str(numQueriesEvaluated)+&#34; benchmarks (&#34;+str(numBenchmarks)+&#34; runs) [ms]&#34;
                filename = self.benchmarker.path+&#39;/total_bar_&#39;+ensembler+&#39;.png&#39;
        else:
                #title = &#34;Q&#34;+str(numQuery)+&#34;: &#34;+chartlabel+&#34; [ms] in &#34;+str(query.numRun-query.warmup)+&#34; benchmark test runs&#34;
                filename = self.benchmarker.path+&#39;/query_&#39;+str(numQuery)+&#39;_bar.png&#39;
        print(title)
        print(tabulate(dataframe,headers=dataframe.columns,tablefmt=&#34;grid&#34;, floatfmt=&#34;.2f&#34;))
        # save as boxplot
        self.save(
                dataframe = dataframe,
                title = title,
                filename = filename)
        return dataframe</code></pre>
</details>
</dd>
<dt id="dbmsbenchmarker.reporter.barer.generateAll"><code class="name flex">
<span>def <span class="ident">generateAll</span></span>(<span>self, timer)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates all reports for the benchmarker object for a given timer.
If benchmarker has a fixed query, only reports for this query are generated.
A plot of the total times is generated in any case.
Anonymizes dbms if activated.</p>
<p>:param timer: Timer object
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def generateAll(self, timer):
        &#34;&#34;&#34;
        Generates all reports for the benchmarker object for a given timer.
        If benchmarker has a fixed query, only reports for this query are generated.
        A plot of the total times is generated in any case.
        Anonymizes dbms if activated.

        :param timer: Timer object
        :return: returns nothing
        &#34;&#34;&#34;
        if not self.benchmarker.fixedQuery is None:
                self.generate(self.benchmarker.fixedQuery, timer)
        else:
                if self.benchmarker.bBatch:
                        #range_runs = range(0, query.warmup+query.numRun)
                        range_runs = range(1,len(self.benchmarker.queries)+1)
                else:
                        #range_runs = tqdm(range(0, query.warmup+query.numRun))
                        range_runs = tqdm(range(1,len(self.benchmarker.queries)+1))
                for numQuery in range_runs:
                        query = tools.query(self.benchmarker.queries[numQuery-1])
                        # is query active?
                        if not query.active:
                                continue
                        logging.debug(&#34;Bar Chart Q&#34;+str(numQuery))
                        self.generate(numQuery, timer)
        self.generate(numQuery=None, timer=timer)</code></pre>
</details>
</dd>
<dt id="dbmsbenchmarker.reporter.barer.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, dataframe, title, filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Saves report of a given query as bar chart image per timer.
Anonymizes dbms if activated.</p>
<p>:param dataframe: Report data given as a pandas DataFrame
:param title: Title of the report
:param filename: Name of the file the report will be saved to
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def save(self, dataframe, title, filename):
        &#34;&#34;&#34;
        Saves report of a given query as bar chart image per timer.
        Anonymizes dbms if activated.

        :param dataframe: Report data given as a pandas DataFrame
        :param title: Title of the report
        :param filename: Name of the file the report will be saved to
        :return: returns nothing
        &#34;&#34;&#34;
        # plot
        dataframe.plot.bar(stacked=True)
        # rotate labels
        plt.xticks(rotation=70, fontsize=12)
        # align box to labels
        plt.tight_layout()
        # set title
        plt.legend(title=title)
        # save
        plt.savefig(filename)
        plt.close()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dbmsbenchmarker.reporter.reporter" href="#dbmsbenchmarker.reporter.reporter">reporter</a></b></code>:
<ul class="hlist">
<li><code><a title="dbmsbenchmarker.reporter.reporter.init" href="#dbmsbenchmarker.reporter.reporter.init">init</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="dbmsbenchmarker.reporter.boxploter"><code class="flex name class">
<span>class <span class="ident">boxploter</span></span>
<span>(</span><span>benchmarker)</span>
</code></dt>
<dd>
<section class="desc"><p>Class for generating reports.
Generates a boxplot of the time series and saves it to disk.</p>
<p>Construct a new 'reporter' object.</p>
<p>:param benchmarker: Object of benchmarker containing information about queries, connections and benchmark times
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class boxploter(reporter):
        &#34;&#34;&#34;
        Class for generating reports.
        Generates a boxplot of the time series and saves it to disk.
        &#34;&#34;&#34;
        def __init__(self, benchmarker):
                reporter.__init__(self, benchmarker)
        def save(self, dataframe, title, filename):
                &#34;&#34;&#34;
                Saves report of a given query as boxplot image per timer.
                Anonymizes dbms if activated.

                :param dataframe: Report data given as a pandas DataFrame (rows=dbms, cols=benchmarks)
                :param title: Title of the report
                :param filename: Name of the file the report will be saved to
                :return: returns nothing
                &#34;&#34;&#34;
                # test if any rows left
                if len(dataframe.index) &lt; 1:
                        return False
                # move index to first column
                dataframe.reset_index(level=0, inplace=True)
                # unpivot
                df_unpivot = pd.melt(dataframe, id_vars=&#39;DBMS&#39;)
                # drop one column
                df_unpivot=df_unpivot.drop(labels=&#39;variable&#39;,axis=1)
                # name columns
                df_unpivot.columns = [&#39;DBMS&#39;, &#39;time [ms]&#39;]
                # anonymize dbms already done
                #df_unpivot[&#39;DBMS&#39;] = df_unpivot[&#39;DBMS&#39;].map(tools.dbms.anonymizer)
                # plot
                boxplot = df_unpivot.boxplot(by=&#39;DBMS&#39;, grid=False)
                # rotate labels
                plt.xticks(rotation=70)
                # align box to labels
                plt.tight_layout()
                # set title and no subtitle
                plt.title(title)
                plt.suptitle(&#34;&#34;)
                # save
                plt.savefig(filename, bbox_inches=&#39;tight&#39;)
                plt.close()
        def generate(self, numQuery, timer):
                &#34;&#34;&#34;
                Generates a boxplot of the time series and saves it to disk.
                Anonymizes dbms if activated.

                :param numQuery: Number of query to generate report of
                :param timer: Timer containing benchmark results
                :return: returns nothing
                &#34;&#34;&#34;
                for t in timer:
                        # are there benchmarks for this query?
                        if not t.checkForSuccessfulBenchmarks(numQuery):
                                continue
                        query = tools.query(self.benchmarker.queries[numQuery-1])
                        # is timer active for this query?
                        if not query.timer[t.name][&#39;active&#39;]:
                                continue
                        # is query active?
                        if not query.active:
                                continue
                        # benchmark times as a dataframe
                        df = self.benchmarker.benchmarksToDataFrame(numQuery, t)
                        logging.debug(&#34;Boxplot Q&#34;+str(numQuery)+&#34; for timer &#34;+t.name)
                        df = df.drop(range(1,query.warmup+1),axis=1)
                        df = df.drop(range(query.numRunEnd+1, query.numRun+1),axis=1)
                        # save as boxplot
                        self.save(
                                dataframe = df,
                                title = &#34;Q&#34;+str(numQuery)+&#34;: Time &#34;+t.name+&#34; [ms] in &#34;+str(len(df.columns))+&#34; test runs&#34;,
                                filename = self.benchmarker.path+&#39;/query_&#39;+str(numQuery)+&#39;_&#39;+t.name+&#39;_boxplot.png&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbmsbenchmarker.reporter.reporter" href="#dbmsbenchmarker.reporter.reporter">reporter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dbmsbenchmarker.reporter.boxploter.generate"><code class="name flex">
<span>def <span class="ident">generate</span></span>(<span>self, numQuery, timer)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates a boxplot of the time series and saves it to disk.
Anonymizes dbms if activated.</p>
<p>:param numQuery: Number of query to generate report of
:param timer: Timer containing benchmark results
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def generate(self, numQuery, timer):
        &#34;&#34;&#34;
        Generates a boxplot of the time series and saves it to disk.
        Anonymizes dbms if activated.

        :param numQuery: Number of query to generate report of
        :param timer: Timer containing benchmark results
        :return: returns nothing
        &#34;&#34;&#34;
        for t in timer:
                # are there benchmarks for this query?
                if not t.checkForSuccessfulBenchmarks(numQuery):
                        continue
                query = tools.query(self.benchmarker.queries[numQuery-1])
                # is timer active for this query?
                if not query.timer[t.name][&#39;active&#39;]:
                        continue
                # is query active?
                if not query.active:
                        continue
                # benchmark times as a dataframe
                df = self.benchmarker.benchmarksToDataFrame(numQuery, t)
                logging.debug(&#34;Boxplot Q&#34;+str(numQuery)+&#34; for timer &#34;+t.name)
                df = df.drop(range(1,query.warmup+1),axis=1)
                df = df.drop(range(query.numRunEnd+1, query.numRun+1),axis=1)
                # save as boxplot
                self.save(
                        dataframe = df,
                        title = &#34;Q&#34;+str(numQuery)+&#34;: Time &#34;+t.name+&#34; [ms] in &#34;+str(len(df.columns))+&#34; test runs&#34;,
                        filename = self.benchmarker.path+&#39;/query_&#39;+str(numQuery)+&#39;_&#39;+t.name+&#39;_boxplot.png&#39;)</code></pre>
</details>
</dd>
<dt id="dbmsbenchmarker.reporter.boxploter.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, dataframe, title, filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Saves report of a given query as boxplot image per timer.
Anonymizes dbms if activated.</p>
<p>:param dataframe: Report data given as a pandas DataFrame (rows=dbms, cols=benchmarks)
:param title: Title of the report
:param filename: Name of the file the report will be saved to
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def save(self, dataframe, title, filename):
        &#34;&#34;&#34;
        Saves report of a given query as boxplot image per timer.
        Anonymizes dbms if activated.

        :param dataframe: Report data given as a pandas DataFrame (rows=dbms, cols=benchmarks)
        :param title: Title of the report
        :param filename: Name of the file the report will be saved to
        :return: returns nothing
        &#34;&#34;&#34;
        # test if any rows left
        if len(dataframe.index) &lt; 1:
                return False
        # move index to first column
        dataframe.reset_index(level=0, inplace=True)
        # unpivot
        df_unpivot = pd.melt(dataframe, id_vars=&#39;DBMS&#39;)
        # drop one column
        df_unpivot=df_unpivot.drop(labels=&#39;variable&#39;,axis=1)
        # name columns
        df_unpivot.columns = [&#39;DBMS&#39;, &#39;time [ms]&#39;]
        # anonymize dbms already done
        #df_unpivot[&#39;DBMS&#39;] = df_unpivot[&#39;DBMS&#39;].map(tools.dbms.anonymizer)
        # plot
        boxplot = df_unpivot.boxplot(by=&#39;DBMS&#39;, grid=False)
        # rotate labels
        plt.xticks(rotation=70)
        # align box to labels
        plt.tight_layout()
        # set title and no subtitle
        plt.title(title)
        plt.suptitle(&#34;&#34;)
        # save
        plt.savefig(filename, bbox_inches=&#39;tight&#39;)
        plt.close()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dbmsbenchmarker.reporter.reporter" href="#dbmsbenchmarker.reporter.reporter">reporter</a></b></code>:
<ul class="hlist">
<li><code><a title="dbmsbenchmarker.reporter.reporter.generateAll" href="#dbmsbenchmarker.reporter.reporter.generateAll">generateAll</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.reporter.init" href="#dbmsbenchmarker.reporter.reporter.init">init</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="dbmsbenchmarker.reporter.dataframer"><code class="flex name class">
<span>class <span class="ident">dataframer</span></span>
<span>(</span><span>benchmarker)</span>
</code></dt>
<dd>
<section class="desc"><p>Class for generating reports.
Generates a data frame of the benchmark times and saves it to disk as a pickle file.</p>
<p>Construct a new 'reporter' object.</p>
<p>:param benchmarker: Object of benchmarker containing information about queries, connections and benchmark times
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class dataframer(reporter):
        &#34;&#34;&#34;
        Class for generating reports.
        Generates a data frame of the benchmark times and saves it to disk as a pickle file.
        &#34;&#34;&#34;
        def __init__(self, benchmarker):
                reporter.__init__(self, benchmarker)
        def save(self, dataframe, title, subtitle, filename):
                &#34;&#34;&#34;
                Saves report of a given query as a dataframe.
                Anonymizes dbms if activated.

                :param dataframe: Report data given as a pandas DataFrame (rows=dbms, cols=benchmarks)
                :param title: Title of the report
                :param subtitle: Subtitle of the report
                :param filename: Name of the file the report will be saved to
                :return: returns nothing
                &#34;&#34;&#34;
                # test if any rows left
                if len(dataframe.index) &lt; 1:
                        return False
                # transpose
                df_transposed = dataframe.transpose()
                # add index name
                df_transposed.index.name = subtitle
                # plot
                f = open(filename, &#34;wb&#34;)
                pickle.dump(df_transposed, f)
                f.close()
        def generate(self, numQuery, timer):
                &#34;&#34;&#34;
                Generates a data frame of the benchmark times and saves it to disk as a pickle file.
                Anonymizes dbms if activated.

                :param numQuery: Number of query to generate report of
                :param timer: Timer containing benchmark results
                :return: returns nothing
                &#34;&#34;&#34;
                for t in timer:
                        # are there benchmarks for this query?
                        if not t.checkForSuccessfulBenchmarks(numQuery):
                                continue
                        query = tools.query(self.benchmarker.queries[numQuery-1])
                        # is timer active for this query?
                        if not query.timer[t.name][&#39;active&#39;]:
                                continue
                        # is query active?
                        if not query.active:
                                continue
                        # benchmark times as a datarame
                        df = self.benchmarker.benchmarksToDataFrame(numQuery, t)
                        logging.debug(&#34;Dataframe Q&#34;+str(numQuery)+&#34; for timer &#34;+t.name)
                        # save as plot
                        self.save(
                                dataframe = df,
                                title = &#34;Q&#34;+str(numQuery)+&#34;: Time &#34;+t.name+&#34; [ms]&#34;,
                                subtitle = &#34;Warmup = &#34;+str(query.warmup)+&#34;, test runs = &#34;+str(query.numRun)+&#34;, cooldown = &#34;+str(query.cooldown),
                                filename = self.benchmarker.path+&#39;/query_&#39;+str(numQuery)+&#39;_&#39;+t.name+&#39;_dataframe.pickle&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbmsbenchmarker.reporter.reporter" href="#dbmsbenchmarker.reporter.reporter">reporter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dbmsbenchmarker.reporter.dataframer.generate"><code class="name flex">
<span>def <span class="ident">generate</span></span>(<span>self, numQuery, timer)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates a data frame of the benchmark times and saves it to disk as a pickle file.
Anonymizes dbms if activated.</p>
<p>:param numQuery: Number of query to generate report of
:param timer: Timer containing benchmark results
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def generate(self, numQuery, timer):
        &#34;&#34;&#34;
        Generates a data frame of the benchmark times and saves it to disk as a pickle file.
        Anonymizes dbms if activated.

        :param numQuery: Number of query to generate report of
        :param timer: Timer containing benchmark results
        :return: returns nothing
        &#34;&#34;&#34;
        for t in timer:
                # are there benchmarks for this query?
                if not t.checkForSuccessfulBenchmarks(numQuery):
                        continue
                query = tools.query(self.benchmarker.queries[numQuery-1])
                # is timer active for this query?
                if not query.timer[t.name][&#39;active&#39;]:
                        continue
                # is query active?
                if not query.active:
                        continue
                # benchmark times as a datarame
                df = self.benchmarker.benchmarksToDataFrame(numQuery, t)
                logging.debug(&#34;Dataframe Q&#34;+str(numQuery)+&#34; for timer &#34;+t.name)
                # save as plot
                self.save(
                        dataframe = df,
                        title = &#34;Q&#34;+str(numQuery)+&#34;: Time &#34;+t.name+&#34; [ms]&#34;,
                        subtitle = &#34;Warmup = &#34;+str(query.warmup)+&#34;, test runs = &#34;+str(query.numRun)+&#34;, cooldown = &#34;+str(query.cooldown),
                        filename = self.benchmarker.path+&#39;/query_&#39;+str(numQuery)+&#39;_&#39;+t.name+&#39;_dataframe.pickle&#39;)</code></pre>
</details>
</dd>
<dt id="dbmsbenchmarker.reporter.dataframer.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, dataframe, title, subtitle, filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Saves report of a given query as a dataframe.
Anonymizes dbms if activated.</p>
<p>:param dataframe: Report data given as a pandas DataFrame (rows=dbms, cols=benchmarks)
:param title: Title of the report
:param subtitle: Subtitle of the report
:param filename: Name of the file the report will be saved to
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def save(self, dataframe, title, subtitle, filename):
        &#34;&#34;&#34;
        Saves report of a given query as a dataframe.
        Anonymizes dbms if activated.

        :param dataframe: Report data given as a pandas DataFrame (rows=dbms, cols=benchmarks)
        :param title: Title of the report
        :param subtitle: Subtitle of the report
        :param filename: Name of the file the report will be saved to
        :return: returns nothing
        &#34;&#34;&#34;
        # test if any rows left
        if len(dataframe.index) &lt; 1:
                return False
        # transpose
        df_transposed = dataframe.transpose()
        # add index name
        df_transposed.index.name = subtitle
        # plot
        f = open(filename, &#34;wb&#34;)
        pickle.dump(df_transposed, f)
        f.close()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dbmsbenchmarker.reporter.reporter" href="#dbmsbenchmarker.reporter.reporter">reporter</a></b></code>:
<ul class="hlist">
<li><code><a title="dbmsbenchmarker.reporter.reporter.generateAll" href="#dbmsbenchmarker.reporter.reporter.generateAll">generateAll</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.reporter.init" href="#dbmsbenchmarker.reporter.reporter.init">init</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="dbmsbenchmarker.reporter.latexer"><code class="flex name class">
<span>class <span class="ident">latexer</span></span>
<span>(</span><span>benchmarker, templatefolder='simple')</span>
</code></dt>
<dd>
<section class="desc"><p>Class for generating reports.
This class generates a survey in latex and saves it to disk.
The survey has one page per timer.</p>
<p>Construct a new 'reporter' object.</p>
<p>:param benchmarker: Object of benchmarker containing information about queries, connections and benchmark times
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class latexer(reporter):
        &#34;&#34;&#34;
        Class for generating reports.
        This class generates a survey in latex and saves it to disk.
        The survey has one page per timer.
        &#34;&#34;&#34;
        def __init__(self, benchmarker, templatefolder=&#34;simple&#34;):
                reporter.__init__(self, benchmarker)
                self.template = {}
                self.templatefolder = templatefolder
                self.readTemplates(templatefolder)
        def readTemplates(self, templatefolder):
                &#34;&#34;&#34;
                Reads content of a template folder

                :param timer: Timer object
                :return: returns nothing
                &#34;&#34;&#34;
                templates = [&#39;reportHead&#39;, &#39;reportFoot&#39;, &#39;query&#39;, &#39;timer&#39;, &#39;appendix&#39;, &#39;appendixquery&#39;, &#39;appendixtimer&#39;]
                for t in templates:
                        with open(&#39;latex/&#39;+templatefolder+&#34;/&#34;+t, &#39;r&#39;) as f:
                                self.template[t]=f.read()
        def useTemplate(self, name, parameter):
                &#34;&#34;&#34;
                Applies parameter to a template and returns filled template

                :param name: Name of the template
                :param parameter: Dict of parameters
                :return: returns template with filled paramter
                &#34;&#34;&#34;
                logging.debug(&#34;useTemplate: &#34;+self.templatefolder+&#34;/&#34;+name)
                return self.template[name].format(**parameter)
        def generateSummary(self):
                &#34;&#34;&#34;
                Generates data for the front page of latex report.

                :return: returns nothing
                &#34;&#34;&#34;
        def init(self):
                &#34;&#34;&#34;
                Generates and saves front page of latex report.

                :return: returns nothing
                &#34;&#34;&#34;
                # generate bar plot of total times
                reporterBar = barer(self.benchmarker)
                dfTotalSum = reporterBar.generate(numQuery=None, timer=self.benchmarker.timers, ensembler=&#39;sum&#39;)
                dfTotalProd = reporterBar.generate(numQuery=None, timer=self.benchmarker.timers, ensembler=&#39;product&#39;)
                # generate area plot of total time
                reporterArea = arear(self.benchmarker)
                dfTotalTime = reporterArea.generate(numQuery=None, timer=self.benchmarker.timers)
                if dfTotalTime is not None:
                        print(tabulate(dfTotalTime,headers=dfTotalTime.columns,tablefmt=&#34;grid&#34;, floatfmt=&#34;.2f&#34;))
                # generate barh plot of total ranking
                dfTotalRank, timers = self.benchmarker.generateSortedTotalRanking()
                #print(title)
                filename = self.benchmarker.path+&#39;/total_barh_rank.png&#39;
                title = &#39;Ranking of &#39;+str(timers)+&#39; timers&#39;
                dfTotalRank.plot.barh()
                plt.xticks(fontsize=14)
                # align box to labels
                plt.tight_layout()
                # set title
                plt.legend(title=title)
                # save
                plt.savefig(filename)
                plt.close()
                print(title)
                print(tabulate(dfTotalRank,headers=dfTotalRank.columns,tablefmt=&#34;grid&#34;, floatfmt=&#34;.2f&#34;))
                if dfTotalSum is not None:
                        dfTotalSum = dfTotalSum.applymap(lambda x: &#39;{:.{prec}f}&#39;.format(x, prec=2))
                if dfTotalProd is not None:
                        dfTotalProd = dfTotalProd.applymap(lambda x: &#39;{:.{prec}f}&#39;.format(x, prec=2))
                dfTotalRank = dfTotalRank.applymap(lambda x: &#39;{:.{prec}f}&#39;.format(x, prec=2))
                # time for ingest
                timesLoad = {}
                for c,cd in self.benchmarker.dbms.items():
                        if cd.connectiondata[&#39;active&#39;] and &#39;timeLoad&#39; in cd.connectiondata: 
                                timesLoad[self.benchmarker.dbms[c].getName()] = cd.connectiondata[&#39;timeLoad&#39;]
                # store in parameter array for replacement in templates
                parameter = self.prepare(0, 0)
                if dfTotalSum is not None:
                        parameter[&#39;totalSum&#39;] = tabulate(dfTotalSum, headers=dfTotalSum.columns, tablefmt=&#34;latex&#34;, floatfmt=&#34;,.2f&#34;, stralign=&#34;right&#34;, showindex=True)
                else:
                        parameter[&#39;totalSum&#39;] = &#34;&#34;
                if dfTotalProd is not None:
                        parameter[&#39;totalProd&#39;] = tabulate(dfTotalProd, headers=dfTotalProd.columns, tablefmt=&#34;latex&#34;, floatfmt=&#34;,.2f&#34;, stralign=&#34;right&#34;, showindex=True)
                else:
                        parameter[&#39;totalProd&#39;] = &#34;&#34;
                parameter[&#39;totalRank&#39;] = tabulate(dfTotalRank, headers=dfTotalRank.columns, tablefmt=&#34;latex&#34;, floatfmt=&#34;,.2f&#34;, stralign=&#34;right&#34;, showindex=True)
                if dfTotalTime is not None:
                        listofnames = [&#39;DBMS &#39;+str(l+1) for l in range(len(dfTotalTime.columns))]
                        dfTotalTimeTranslation = pd.DataFrame(dfTotalTime.columns,index=listofnames,columns=[&#39;DBMS Name&#39;])
                        dfTotalTime.columns = listofnames
                        parameter[&#39;totalTime&#39;] = tabulate(dfTotalTime, headers=dfTotalTime.columns, tablefmt=&#34;latex&#34;, floatfmt=&#34;,.2f&#34;, stralign=&#34;right&#34;, showindex=True)
                        parameter[&#39;totalTime&#39;] += &#34;\\\\&#34;+tabulate(dfTotalTimeTranslation, headers=dfTotalTimeTranslation.columns, tablefmt=&#34;latex&#34;, floatfmt=&#34;,.2f&#34;, stralign=&#34;right&#34;, showindex=True)
                else:
                        parameter[&#39;totalTime&#39;] = &#34;&#34;
                #print(timesLoad)
                if len(timesLoad) &gt; 0:
                        dfIngest = pd.DataFrame.from_dict(timesLoad, orient=&#39;index&#39;)
                        dfIngest.columns=[&#39;Time of Ingestion [s]&#39;]
                        dfIngest.sort_values(by=[&#39;Time of Ingestion [s]&#39;], inplace=True, ascending=False)
                        filename = self.benchmarker.path+&#39;/total_barh_ingest.png&#39;
                        title = &#39;Ingest into &#39;+str(len(dfIngest.index))+&#39; DBMS&#39;
                        dfIngest.plot.barh()
                        plt.xticks(fontsize=14)
                        # align box to labels
                        plt.tight_layout()
                        # set title
                        plt.legend(title=title)
                        # save
                        plt.savefig(filename)
                        plt.close()
                        parameter[&#39;totalIngest&#39;] = tabulate(dfIngest, headers=dfIngest.columns, tablefmt=&#34;latex&#34;, floatfmt=&#34;,.2f&#34;, stralign=&#34;right&#34;, showindex=True)
                else:
                        parameter[&#39;totalIngest&#39;] = &#34;&#34;
                # generate report head
                latex_output = self.useTemplate(&#39;reportHead&#39;, parameter)# self.template[&#39;reportHead&#39;].format(**parameter)
                latex_file = open(self.benchmarker.path+&#34;/benchmarks.tex&#34;, &#34;w&#34;)
                latex_file.write(latex_output)
                latex_file.close()
        def prepare(self, numQuery=0, numTimer=0, timer=None):
                &#34;&#34;&#34;
                Prepares a dict containing data about query and timer.
                This will be used to fill the latex output template.
                Anonymizes dbms if activated.

                :param numQuery: Number of query to collect data from. numQuery=0 for title page
                :param numTimer: Number of timer of this query. First timer is treated differently (subsubsection)
                :param timer: List of timers to collect data from. timer=None for title page
                :return: returns dict of data about query and timer
                &#34;&#34;&#34;
                result = {}
                result[&#39;now&#39;]=str(datetime.datetime.now())
                result[&#39;path&#39;]=self.benchmarker.path
                result[&#39;code&#39;]=self.benchmarker.code
                result[&#39;timeout&#39;]=str(self.benchmarker.timeout)+&#34;s&#34;
                result[&#39;numProcesses&#39;]=self.benchmarker.numProcesses
                result[&#39;runsPerConnection&#39;]=self.benchmarker.runsPerConnection
                if len(self.benchmarker.queryconfig[&#34;intro&#34;]) &gt; 0:
                        result[&#39;intro&#39;] = self.benchmarker.queryconfig[&#34;intro&#34;]+&#34;\\\\&#34;
                # list of active queries for timer #0 = execution
                qs = tools.findSuccessfulQueriesAllDBMS(self.benchmarker, None, self.benchmarker.timers)[0]
                #print(qs)
                # compute total times
                times = {}
                l = list({c for c in {c for q,d in self.benchmarker.protocol[&#39;query&#39;].items() if int(q)-1 in qs for c in d[&#39;durations&#39;].items()}})
                #print(l)
                for i,element in enumerate(l):
                        #print(element)
                        if not element[0] in times:
                                times[element[0]] = element[1]
                        else:
                                times[element[0]] += element[1]
                #print(times)
                # format dbms infos
                def initfilename(c, i):
                        return self.benchmarker.path+&#39;/&#39;+c+&#39;_init_&#39;+str(i)+&#39;.log&#39;
                def hasInitScript(c):
                        return os.path.isfile(initfilename(c,0))
                dbmsinfos = &#34;&#34;
                #for c in sorted(self.benchmarker.dbms.keys()):
                for c in sorted(self.benchmarker.dbms, key=lambda kv: self.benchmarker.dbms[kv].name):
                        if self.benchmarker.dbms[c].connectiondata[&#39;active&#39;]:
                                dbmsdata = self.benchmarker.dbms[c].getName()
                                if not self.benchmarker.anonymize:
                                        dbmsdata += &#34; (&#34;+self.benchmarker.dbms[c].connectiondata[&#34;version&#34;]+&#34;)&#34;
                                dbmsinfos += &#34;\\subsubsection{{{dbmsname}}}&#34;.format(dbmsname=dbmsdata)
                                dbmsinfos += &#34;\\begin{itemize}\n&#34;
                                info = self.benchmarker.dbms[c].connectiondata[&#34;info&#34;]
                                if len(info) &gt; 0:
                                        if not str(info) == info:
                                                dbmsinfos += &#34;\\item &#34;+(&#34;\\item &#34;.join(info))
                                if &#39;connectionmanagement&#39; in self.benchmarker.dbms[c].connectiondata:
                                        connectionmanagement = self.benchmarker.dbms[c].connectiondata[&#39;connectionmanagement&#39;]
                                        if &#34;numProcesses&#34; in connectionmanagement:
                                                dbmsinfos += &#34;\\item \\textbf{Parallel Clients}: &#34;+str(connectionmanagement[&#34;numProcesses&#34;])
                                        if &#34;runsPerConnection&#34; in connectionmanagement:
                                                if connectionmanagement[&#34;runsPerConnection&#34;] &gt; 0:
                                                        dbmsinfos += &#34;\\item \\textbf{Runs per Connection}: &#34;+str(connectionmanagement[&#34;runsPerConnection&#34;])
                                                else:
                                                        dbmsinfos += &#34;\\item \\textbf{Runs per Connection}: Unlimited&#34;
                                        if &#34;timeout&#34; in connectionmanagement:
                                                if connectionmanagement[&#34;timeout&#34;] &gt; 0:
                                                        dbmsinfos += &#34;\\item \\textbf{Timeout}: &#34;+str(connectionmanagement[&#34;timeout&#34;])
                                                else:
                                                        dbmsinfos += &#34;\\item \\textbf{Timeout}: Unlimited&#34;
                                else:
                                        #numProcesses = int(self.benchmarker.dbms[c].connectiondata[&#34;numProcesses&#34;])
                                        #if numProcesses == 0:
                                        numProcesses = int(self.benchmarker.numProcesses)
                                        if not numProcesses == 0:
                                                dbmsinfos += &#34;\\item \\textbf{Clients}: &#34;+str(numProcesses)+&#34; parallel clients&#34;
                                                if self.benchmarker.runsPerConnection &gt; 0:
                                                        dbmsinfos += &#34;\\item \\textbf{Runs per Connection}: &#34;+str(self.benchmarker.runsPerConnection)
                                                else:
                                                        dbmsinfos += &#34;\\item \\textbf{Runs per Connection}: Unlimited&#34;
                                                if self.benchmarker.timeout &gt; 0:
                                                        dbmsinfos += &#34;\\item \\textbf{Timeout}: &#34;+str(self.benchmarker.timeout)
                                                else:
                                                        dbmsinfos += &#34;\\item \\textbf{Timeout}: Unlimited&#34;
                                if &#34;CPU&#34; in self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;]:
                                        dbmsinfos += &#34;\\item \\textbf{CPU}: &#34;+self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;][&#34;CPU&#34;]
                                if &#34;Cores&#34; in self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;]:
                                        dbmsinfos += &#34;\\item \\textbf{Cores}: &#34;+self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;][&#34;Cores&#34;]
                                if &#34;RAM&#34; in self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;]:
                                        dbmsinfos += &#34;\\item \\textbf{RAM}: &#34;+str(self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;][&#34;RAM&#34;])+&#34; GB&#34;
                                if &#34;GPU&#34; in self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;]:
                                        dbmsinfos += &#34;\\item \\textbf{GPU}: &#34;+self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;][&#34;GPU&#34;]
                                if &#34;CUDA&#34; in self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;]:
                                        dbmsinfos += &#34;\\item \\textbf{CUDA}: &#34;+self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;][&#34;CUDA&#34;]
                                if &#34;host&#34; in self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;]:
                                        dbmsinfos += &#34;\\item \\textbf{Host}: &#34;+self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;][&#34;host&#34;]
                                if &#34;disk&#34; in self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;]:
                                        dbmsinfos += &#34;\\item \\textbf{Docker Disk Space Used}: &#34;+self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;][&#34;disk&#34;]
                                if &#34;instance&#34; in self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;]:
                                        dbmsinfos += &#34;\\item \\textbf{Instance}: &#34;+self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;][&#34;instance&#34;]
                                if &#34;timeLoad&#34; in self.benchmarker.dbms[c].connectiondata:
                                        dbmsinfos += &#34;\\item \\textbf{Time Ingest}: &#34;+tools.formatDuration(self.benchmarker.dbms[c].connectiondata[&#34;timeLoad&#34;]*1000.0)
                                if c in times:
                                        dbmsinfos += &#34;\\item \\textbf{Time Benchmarks}: &#34;+tools.formatDuration(times[c])
                                        if &#39;priceperhourdollar&#39; in self.benchmarker.dbms[c].connectiondata:
                                                if &#34;timeLoad&#34; in self.benchmarker.dbms[c].connectiondata:
                                                        time = times[c] + self.benchmarker.dbms[c].connectiondata[&#34;timeLoad&#34;]*1000.0
                                                        dbmsinfos += &#34;\\item \\textbf{Time Total}: &#34;+tools.formatDuration(time)
                                                else:
                                                        time = times[c]
                                                dbmsinfos += &#34;\\item \\textbf{{Price}}: \\${:.{prec}f} (\\${:.{prec}f}/h)&#34;.format(self.benchmarker.dbms[c].connectiondata[&#39;priceperhourdollar&#39;]*time/3600000, self.benchmarker.dbms[c].connectiondata[&#39;priceperhourdollar&#39;], prec=2)
                                if hasInitScript(c) and not self.benchmarker.dbms[c].anonymous:
                                        dbmsinfos += &#34;\\item\\hyperref[initscript:{dbms}]{{Initialisation scripts}}&#34;.format(dbms=c)
                                #dbmsinfos += &#34;\\item {}\n&#34;.format(info)
                                #dbmsinfos += &#34;\\item \\textbf{{{}}}: {}\n&#34;.format(dbmsdata, info)
                                dbmsinfos += &#34;\\end{itemize}&#34;
                result[&#39;dbmsinfos&#39;] = dbmsinfos
                # appendix start: query survey
                result[&#39;querySurvey&#39;] = &#39;&#39;
                for i in range(1, len(self.benchmarker.queries)+1):
                        queryObject = tools.query(self.benchmarker.queries[i-1])
                        result[&#39;querySurvey&#39;] += &#34;\n\\\\\\noindent\\hyperref[benchmark:{code}-Q{queryNumber}]{{\\textbf{{Q{queryNumber}: {queryTitle}}}}}\n&#34;.format(code=self.benchmarker.code, queryNumber=i, queryTitle=queryObject.title)
                        if not queryObject.active:
                                result[&#39;querySurvey&#39;] += &#39;\\\\inactive&#39;
                                continue
                        if len(self.benchmarker.protocol[&#39;query&#39;][str(i)][&#39;parameter&#39;]) &gt; 0:
                                result[&#39;querySurvey&#39;] += &#34;\\\\\\hyperref[parameter:{code}-Q{queryNumber}]{{Parametrized}}&#34;.format(**result, queryNumber=i)
                        l = self.benchmarker.protocol[&#39;query&#39;][str(i)][&#39;dataStorage&#39;]
                        if len(l) &gt; 0 and len(l[0]) &gt; 0 and len(l[0][0]) &gt; 0:
                                l = [x for l1 in l for l2 in l1 for x in l2]
                                result[&#39;querySurvey&#39;] += &#34;\\\\\\hyperref[data:{code}-Q{queryNumber}]{{Storage size}}: &#34;.format(**result, queryNumber=i)+str(sys.getsizeof(l))+&#34; bytes (&#34;+queryObject.result+&#34;)&#34;
                        for connection, error in self.benchmarker.protocol[&#39;query&#39;][str(i)][&#39;errors&#39;].items():
                                if len(error) &gt; 0 and self.benchmarker.dbms[connection].connectiondata[&#39;active&#39;]:
                                        result[&#39;querySurvey&#39;] += &#34;\\\\\\noindent &#34;+self.benchmarker.dbms[connection].getName()+&#34;: {\\textit{\\error{&#34;+tools.tex_escape(error)+&#34;}}}\n&#34;
                                        #result[&#39;querySurvey&#39;] += &#34;\\\\\\noindent &#34;+connection+&#34;: {\\tiny{\\begin{verbatim}&#34;+error+&#34;\\end{verbatim}}}\n&#34;
                                        #result[&#39;querySurvey&#39;] += &#34;\\\\&#34;+connection+&#34;: Error&#34;
                        for connection, size in self.benchmarker.protocol[&#39;query&#39;][str(i)][&#39;sizes&#39;].items():
                                if size &gt; 0 and self.benchmarker.dbms[connection].connectiondata[&#39;active&#39;]:
                                        result[&#39;querySurvey&#39;] += &#34;\\\\\\noindent &#34;+self.benchmarker.dbms[connection].getName()+&#34;: Received data = &#34;+tools.sizeof_fmt(size)+&#34;\n&#34;
                                        #result[&#39;querySurvey&#39;] += &#34;\\\\&#34;+connection+&#34;: Error&#34;
                #print(result[&#39;querySurvey&#39;])
                # format title of benchmark
                if len(self.benchmarker.queryconfig[&#34;name&#34;]) &gt; 0:
                        benchmarkName = self.benchmarker.queryconfig[&#34;name&#34;]
                else:
                        benchmarkName = self.benchmarker.path
                # if no query: title is section
                if numQuery == 0:
                        benchmarkName = &#39;\\section{%s}&#39; % (benchmarkName)
                result[&#39;benchmarkName&#39;] = benchmarkName
                summary = &#34;&#34;
                numShownPlots = 0
                for i,q in enumerate(self.benchmarker.queries):
                        if self.benchmarker.timerExecution.checkForSuccessfulBenchmarks(i+1):
                                query = tools.query(q)
                                if not query.active:
                                        #print(&#34;skip&#34;)
                                        continue
                                numShownPlots = numShownPlots + 1
                                summary += &#34;&#34;&#34;\\begin{{minipage}}[t]{{0.45\\textwidth}}
\\hyperref[benchmark:{code}-Q{queryNumber}]{{\\textbf{{Q{queryNumber}: {queryTitle}}}}}\\\\
\\includegraphics[height=0.8\\textwidth]{{query_{queryNumber}_bar.png}}
\\end{{minipage}}\n&#34;&#34;&#34;.format(code=self.benchmarker.code, path=self.benchmarker.path, queryNumber=i+1, queryTitle=query.title)
                                if i+1 &lt; len(self.benchmarker.queries) and (numShownPlots)%2:
                                        summary += &#34;\\hfill&#34;
                result[&#39;summary&#39;] = summary
                # init scripts
                result[&#39;initscript&#39;] = &#34;&#34;
                for c in self.benchmarker.dbms:
                        i = 0
                        if hasInitScript(c) and self.benchmarker.dbms[c].connectiondata[&#39;active&#39;] and not self.benchmarker.dbms[c].anonymous:
                                result[&#39;initscript&#39;] += &#34;\\newpage\n\\subsection{{Initscript {dbms}}}\\label{{initscript:{dbms}}}\n&#34;.format(dbms=c)
                                #result[&#39;initscript&#39;] += &#34;\\begin{figure}[h]\\centering\n
                                result[&#39;initscript&#39;] += &#34;\\begin{sqlFormatSmall}\n&#34;
                                while True:
                                        filename=initfilename(c,i)
                                        if os.path.isfile(filename):
                                                result[&#39;initscript&#39;] += open(filename).read()
                                                i = i + 1
                                        else:
                                                break
                                result[&#39;initscript&#39;] += &#34;\n\\end{sqlFormatSmall}\n&#34;
                                #result[&#39;initscript&#39;] += &#34;\\caption{{Init script {dbms}}}\\end{{figure}}&#34;.format(dbms=c)
                # are there benchmarks for this query?
                if numQuery &gt; 0 and self.benchmarker.timerExecution.checkForSuccessfulBenchmarks(numQuery):
                        result[&#39;queryNumber&#39;]=numQuery
                        query = tools.query(self.benchmarker.queries[numQuery-1])
                        # format duration
                        result[&#39;duration&#39;] = tools.formatDuration(self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;duration&#39;])
                        result[&#39;durations&#39;] = &#34;\\begin{itemize}\n&#34;
                        for c, d in self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;durations&#39;].items():
                                result[&#39;durations&#39;] += &#39;\\item\\textbf{&#39;+self.benchmarker.dbms[c].getName()+&#39;}: &#39;+tools.formatDuration(d)+&#39;\n&#39;
                        result[&#39;durations&#39;] += &#34;\\end{itemize}\n&#34;
                        # format errors
                        errors = &#39;&#39;
                        for key, value in self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;errors&#39;].items():
                                if not self.benchmarker.dbms[key].connectiondata[&#39;active&#39;]:
                                        continue
                                if len(value) &gt; 0:
                                        #firstpos = value.find(&#39;: &#39;)
                                        #if firstpos &gt; 0:
                                        #       #errors += &#39;\\\\&#39;+self.benchmarker.dbms[key].getName() + &#39;: \\verb|&#39; + value[(firstpos+2):] + &#39;|\\\\&#39;
                                        #       errors += &#39;\\\\&#39;+self.benchmarker.dbms[key].getName() + &#39;: \\error{&#39; + tools.tex_escape(value[(firstpos+2):]) + &#39;}\\\\&#39;
                                        #else:
                                        #       #errors += &#39;\\\\&#39;+self.benchmarker.dbms[key].getName() + &#39;: \\verb|&#39; + value + &#39;|\\\\&#39;
                                        #       errors += &#39;\\\\&#39;+self.benchmarker.dbms[key].getName() + &#39;: \\error{&#39; + tools.tex_escape(value) + &#39;}\\\\&#39;
                                        errors += &#39;\\\\&#39;+self.benchmarker.dbms[key].getName() + &#39;: \\error{&#39; + tools.tex_escape(value) + &#39;}\\\\&#39;
                        if len(errors) &gt; 0:
                                errors = &#39;\\subsubsection{{Error}}\\label{{error:{code}-Q{queryNumber}}}&#39;.format(**result)+errors
                        errors += &#39;&#39;
                        result[&#39;errors&#39;] = errors
                        # format parameter
                        parameter = &#39;&#39;
                        showParameter = self.benchmarker.queryconfig[&#34;reporting&#34;][&#34;queryparameter&#34;]
                        if showParameter:
                                if len(self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;parameter&#39;]) &gt; 0:
                                        parameter += &#39;\\subsubsection{{Parameter}}\\label{{parameter:{code}-Q{queryNumber}}}&#39;.format(**result)
                                        #parameter += &#39;\\subsubsection{Parameter}&#39;
                                        listParameter = self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;parameter&#39;]
                                        dataframeParameter = pd.DataFrame.from_records(listParameter)
                                        dataframeParameter.index=range(1,len(listParameter)+1)
                                        if showParameter == &#39;first&#39;:
                                                dataframeParameter = dataframeParameter.iloc[0:1, :]
                                        parameter += tabulate(dataframeParameter, headers=dataframeParameter.columns, tablefmt=&#34;latex&#34;, stralign=&#34;right&#34;, showindex=True)
                                        parameter += &#39;\\\\&#39;
                        result[&#39;queryParameter&#39;] = parameter
                        # data
                        result[&#39;data&#39;] = &#34;&#34;
                        showStorage = self.benchmarker.queryconfig[&#34;reporting&#34;][&#34;resultsetPerQuery&#34;]
                        if self.benchmarker.queryconfig[&#34;reporting&#34;][&#34;resultsetPerQuery&#34;]:
                                #print(&#34;resultsetPerQuery&#34;)
                                if not self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;dataStorage&#39;] is None:
                                        result[&#39;data&#39;] += &#39;\\subsubsection{{Received Data}}\\label{{data:{code}-Q{queryNumber}}}&#39;.format(**result)
                                        for i,data in enumerate(self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;dataStorage&#39;]):
                                                if data is not None and len(data) &gt; 0:
                                                        df = pd.DataFrame.from_records(data)
                                                        # first row contains column names
                                                        df.columns = df.iloc[0]
                                                        # remove first row
                                                        df = df[1:]
                                                        if query.result == &#39;result&#39;:
                                                                result[&#39;data&#39;] += &#34;\\noindent\\textbf{Result table of run &#34;+str(i+1)+&#34;}:\\\\&#34;
                                                        elif query.result == &#39;hash&#39;:
                                                                result[&#39;data&#39;] += &#34;\\noindent\\textbf{Result hash of run &#34;+str(i+1)+&#34;}:\\\\&#34;
                                                        elif query.result == &#39;size&#39;:
                                                                result[&#39;data&#39;] += &#34;\\noindent\\textbf{Result size of run &#34;+str(i+1)+&#34;}:\\\\&#34;
                                                        if query.restrict_precision:
                                                                precision = query.restrict_precision
                                                        else:
                                                                precision = 2
                                                        if df.empty:
                                                                df.loc[len(df), :] = [&#39;-&#39; for i in range(1,len(df.columns)+1)]
                                                        result[&#39;data&#39;] += tabulate(df, headers=df.columns, tablefmt=&#34;latex&#34;, stralign=&#34;right&#34;, floatfmt=&#34;,.&#34;+str(precision)+&#34;f&#34;, showindex=False)
                                                        result[&#39;data&#39;] += &#39;\\\\\n\n&#39;
                                                        if showStorage == &#34;first&#34;:
                                                                break;
                        # result sets
                        result[&#39;resultSets&#39;] = &#34;&#34;
                        showResultsets = self.benchmarker.queryconfig[&#34;reporting&#34;][&#34;resultsetPerQueryConnection&#34;]
                        if showResultsets:
                                #print(&#34;resultsetPerQueryConnection&#34;)
                                if not self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;resultSets&#39;] is None:
                                        for c, sets in self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;resultSets&#39;].items():
                                                if len(sets) &gt; 0:
                                                        # show result set because there is an error
                                                        result[&#39;resultSets&#39;] += &#39;\\subsubsection{Received Data of &#39;+self.benchmarker.dbms[c].getName()+&#39;}&#39;
                                                        for i, data in enumerate(sets):
                                                                if data is not None and len(data) &gt; 0:
                                                                        if showResultsets == &#34;differing&#34;:
                                                                                # only show result sets differing from data storage
                                                                                if len(self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;dataStorage&#39;]) &gt; i:
                                                                                        if self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;dataStorage&#39;][i] == self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;resultSets&#39;][c][i]:
                                                                                                #print(&#34;Same result for run &#34;+str(i)+&#34; of query &#34;+str(numQuery))
                                                                                                continue
                                                                                else:
                                                                                        if self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;dataStorage&#39;][0] == self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;resultSets&#39;][c][i]:
                                                                                                #print(&#34;Same result for run &#34;+str(i)+&#34; of query &#34;+str(numQuery))
                                                                                                continue
                                                                        df = pd.DataFrame.from_records(data)
                                                                        # first row contains column names
                                                                        df.columns = df.iloc[0]
                                                                        # remove first row
                                                                        df = df[1:]
                                                                        if query.result == &#39;result&#39;:
                                                                                result[&#39;resultSets&#39;] += &#34;\\noindent\\textbf{Result table of run &#34;+str(i+1)+&#34;}:\\\\&#34;
                                                                        elif query.result == &#39;hash&#39;:
                                                                                result[&#39;resultSets&#39;] += &#34;\\noindent\\textbf{Result hash of run &#34;+str(i+1)+&#34;}:\\\\&#34;
                                                                        elif query.result == &#39;size&#39;:
                                                                                result[&#39;resultSets&#39;] += &#34;\\noindent\\textbf{Result size of run &#34;+str(i+1)+&#34;}:\\\\&#34;
                                                                        if query.restrict_precision:
                                                                                precision = query.restrict_precision
                                                                        else:
                                                                                precision = 2
                                                                        if df.empty:
                                                                                df.loc[len(df), :] = [&#39;-&#39; for i in range(1,len(df.columns)+1)]
                                                                        result[&#39;resultSets&#39;] += tabulate(df, headers=df.columns, tablefmt=&#34;latex&#34;, stralign=&#34;right&#34;, floatfmt=&#34;,.&#34;+str(precision)+&#34;f&#34;, showindex=False)
                                                                        result[&#39;resultSets&#39;] += &#39;\\\\\n\n&#39;
                                                                        if showResultsets == &#34;first&#34;:
                                                                                break;
                        # format title of query
                        queryName = &#39;Query %d%s&#39; % (numQuery, &#39;: &#39;+query.title)
                        result[&#39;queryName&#39;] = queryName
                        result[&#39;queryString&#39;] = query.query
                        queryNotes = &#34;&#34;
                        for c in query.DBMS:
                                for connectionname, connection in self.benchmarker.dbms.items():
                                        if connectionname.startswith(c) and self.benchmarker.dbms[connectionname].connectiondata[&#39;active&#39;]:
                                                queryNotes += self.benchmarker.dbms[connectionname].getName() + &#39;: Different query\n\\begin{sqlFormat}\n&#39; + query.DBMS[c] + &#39;\n\\end{sqlFormat}&#39;
                        result[&#39;queryNotes&#39;] = queryNotes
                        result[&#39;warmup&#39;]=str(query.warmup)
                        result[&#39;cooldown&#39;]=str(query.cooldown)
                        result[&#39;run&#39;]=str(query.numRun)
                        result[&#39;start&#39;]=self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;start&#39;]
                        result[&#39;end&#39;]=self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;end&#39;]
                        # hardware metrics
                        result[&#39;hardwareMetrics&#39;] = &#34;&#34;
                        for connectionname, connection in self.benchmarker.dbms.items():
                                if self.benchmarker.dbms[connectionname].hasHardwareMetrics():
                                        metricsReporter = monitor.metrics(self.benchmarker)
                                        #result[&#39;hardwareMetrics&#39;] = monitor.metrics.latex.format(**result)
                                        result[&#39;hardwareMetrics&#39;] = metricsReporter.generateLatexForQuery(result)
                                        break
                        # report per timer
                        if numTimer &gt; 0:
                                result[&#39;nameTimer&#39;] = timer.name
                                # format times for output
                                header = tools.timer.header_stats.copy()
                                # add factor column
                                header.insert(1,&#34;factor&#34;)
                                # convert to DataFrame
                                dataframe = self.benchmarker.statsToDataFrame(numQuery, timer)
                                # test if any rows left
                                if dataframe.empty:
                                        return {}
                                # print transfer table in latex
                                table = tabulate(dataframe,headers=header, tablefmt=&#34;latex&#34;, stralign=&#34;right&#34;, floatfmt=&#34;,.2f&#34;, showindex=True)
                                # align dbms name to the left
                                table = table.replace(&#39;\\begin{tabular}{r&#39;, &#39;\\begin{tabular}{l&#39;)
                                result[&#39;table&#39;] = table
                                result[&#39;tableName&#39;] = &#34;Time &#34;+timer.name
                                result[&#39;timerName&#39;] = timer.name
                #print(result)
                return result
        def generate(self, numQuery, timer):
                &#34;&#34;&#34;
                Generates latex report (no front page, given query) for given list of timers.
                Anonymizes dbms if activated.

                :param numQuery: Number of query to collect data from. numQuery=0 for title page
                :param timer: List of timers to collect data from. timer=None for title page
                :return: returns nothing
                &#34;&#34;&#34;
                # generate report pages per started query
                for numQuery in range(1, len(self.benchmarker.queries)+1):
                        # are there benchmarks for this query?
                        if not self.benchmarker.timerExecution.checkForSuccessfulBenchmarks(numQuery):
                                continue
                        # is this query active?
                        query = tools.query(self.benchmarker.queries[numQuery-1])
                        if not query.active:
                                continue
                        parameter = self.prepare(numQuery, 0)
                        latex_output = self.useTemplate(&#39;query&#39;, parameter)
                        for numTimer,t in enumerate(timer):
                                if not t.checkForSuccessfulBenchmarks(numQuery):
                                        continue
                                # is timer active for this query?
                                if not query.timer[t.name][&#39;active&#39;]:
                                        continue
                                parameter = self.prepare(numQuery, numTimer+1, t)
                                if len(parameter) &gt; 0:
                                        latex_output += self.useTemplate(&#39;timer&#39;, parameter)
                        # save latex in file, append to existing
                        latex_file = open(self.benchmarker.path+&#34;/benchmarks.tex&#34;, &#34;a+&#34;)
                        latex_file.write(latex_output)
                        latex_file.close()
                # generate report appendix pages per started query
                parameter = self.prepare(0, 0)
                latex_output = self.useTemplate(&#39;appendix&#39;, parameter)
                latex_file = open(self.benchmarker.path+&#34;/benchmarks.tex&#34;, &#34;a+&#34;)
                latex_file.write(latex_output)
                latex_file.close()
                for numQuery in range(1, len(self.benchmarker.queries)+1):
                        # are there benchmarks for this query?
                        if not self.benchmarker.timerExecution.checkForSuccessfulBenchmarks(numQuery):
                                continue
                        # is this query active?
                        query = tools.query(self.benchmarker.queries[numQuery-1])
                        if not query.active:
                                continue
                        parameter = self.prepare(numQuery, 0)
                        latex_output = self.useTemplate(&#39;appendixquery&#39;, parameter)
                        for numTimer,t in enumerate(timer):
                                if not t.checkForSuccessfulBenchmarks(numQuery):
                                        continue
                                parameter = self.prepare(numQuery, numTimer+1, t)
                                if len(parameter) &gt; 0:
                                        latex_output += self.useTemplate(&#39;appendixtimer&#39;, parameter) #self.template[&#39;timer&#39;].format(**parameter)
                        # save latex in file, append to existing
                        latex_file = open(self.benchmarker.path+&#34;/benchmarks.tex&#34;, &#34;a+&#34;)
                        latex_file.write(latex_output)
                        latex_file.close()
                # generate foot of report
                latex_output = self.useTemplate(&#39;reportFoot&#39;, parameter)
                # save latex in file, append to existing
                latex_file = open(self.benchmarker.path+&#34;/benchmarks.tex&#34;, &#34;a+&#34;)
                latex_file.write(latex_output)
                latex_file.close()
        def generateAll(self, timer):
                &#34;&#34;&#34;
                Generates complete latex report (front page, all queries and connections) for given list of timers.
                Anonymizes dbms if activated.

                :param timer: List of timer objects
                &#34;&#34;&#34;
                self.init()
                self.generate(1, timer)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbmsbenchmarker.reporter.reporter" href="#dbmsbenchmarker.reporter.reporter">reporter</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="dbmsbenchmarker.reporter.latexerPagePerQuery" href="#dbmsbenchmarker.reporter.latexerPagePerQuery">latexerPagePerQuery</a></li>
<li><a title="dbmsbenchmarker.reporter.latexerCustom" href="#dbmsbenchmarker.reporter.latexerCustom">latexerCustom</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dbmsbenchmarker.reporter.latexer.generate"><code class="name flex">
<span>def <span class="ident">generate</span></span>(<span>self, numQuery, timer)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates latex report (no front page, given query) for given list of timers.
Anonymizes dbms if activated.</p>
<p>:param numQuery: Number of query to collect data from. numQuery=0 for title page
:param timer: List of timers to collect data from. timer=None for title page
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def generate(self, numQuery, timer):
        &#34;&#34;&#34;
        Generates latex report (no front page, given query) for given list of timers.
        Anonymizes dbms if activated.

        :param numQuery: Number of query to collect data from. numQuery=0 for title page
        :param timer: List of timers to collect data from. timer=None for title page
        :return: returns nothing
        &#34;&#34;&#34;
        # generate report pages per started query
        for numQuery in range(1, len(self.benchmarker.queries)+1):
                # are there benchmarks for this query?
                if not self.benchmarker.timerExecution.checkForSuccessfulBenchmarks(numQuery):
                        continue
                # is this query active?
                query = tools.query(self.benchmarker.queries[numQuery-1])
                if not query.active:
                        continue
                parameter = self.prepare(numQuery, 0)
                latex_output = self.useTemplate(&#39;query&#39;, parameter)
                for numTimer,t in enumerate(timer):
                        if not t.checkForSuccessfulBenchmarks(numQuery):
                                continue
                        # is timer active for this query?
                        if not query.timer[t.name][&#39;active&#39;]:
                                continue
                        parameter = self.prepare(numQuery, numTimer+1, t)
                        if len(parameter) &gt; 0:
                                latex_output += self.useTemplate(&#39;timer&#39;, parameter)
                # save latex in file, append to existing
                latex_file = open(self.benchmarker.path+&#34;/benchmarks.tex&#34;, &#34;a+&#34;)
                latex_file.write(latex_output)
                latex_file.close()
        # generate report appendix pages per started query
        parameter = self.prepare(0, 0)
        latex_output = self.useTemplate(&#39;appendix&#39;, parameter)
        latex_file = open(self.benchmarker.path+&#34;/benchmarks.tex&#34;, &#34;a+&#34;)
        latex_file.write(latex_output)
        latex_file.close()
        for numQuery in range(1, len(self.benchmarker.queries)+1):
                # are there benchmarks for this query?
                if not self.benchmarker.timerExecution.checkForSuccessfulBenchmarks(numQuery):
                        continue
                # is this query active?
                query = tools.query(self.benchmarker.queries[numQuery-1])
                if not query.active:
                        continue
                parameter = self.prepare(numQuery, 0)
                latex_output = self.useTemplate(&#39;appendixquery&#39;, parameter)
                for numTimer,t in enumerate(timer):
                        if not t.checkForSuccessfulBenchmarks(numQuery):
                                continue
                        parameter = self.prepare(numQuery, numTimer+1, t)
                        if len(parameter) &gt; 0:
                                latex_output += self.useTemplate(&#39;appendixtimer&#39;, parameter) #self.template[&#39;timer&#39;].format(**parameter)
                # save latex in file, append to existing
                latex_file = open(self.benchmarker.path+&#34;/benchmarks.tex&#34;, &#34;a+&#34;)
                latex_file.write(latex_output)
                latex_file.close()
        # generate foot of report
        latex_output = self.useTemplate(&#39;reportFoot&#39;, parameter)
        # save latex in file, append to existing
        latex_file = open(self.benchmarker.path+&#34;/benchmarks.tex&#34;, &#34;a+&#34;)
        latex_file.write(latex_output)
        latex_file.close()</code></pre>
</details>
</dd>
<dt id="dbmsbenchmarker.reporter.latexer.generateAll"><code class="name flex">
<span>def <span class="ident">generateAll</span></span>(<span>self, timer)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates complete latex report (front page, all queries and connections) for given list of timers.
Anonymizes dbms if activated.</p>
<p>:param timer: List of timer objects</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def generateAll(self, timer):
        &#34;&#34;&#34;
        Generates complete latex report (front page, all queries and connections) for given list of timers.
        Anonymizes dbms if activated.

        :param timer: List of timer objects
        &#34;&#34;&#34;
        self.init()
        self.generate(1, timer)</code></pre>
</details>
</dd>
<dt id="dbmsbenchmarker.reporter.latexer.generateSummary"><code class="name flex">
<span>def <span class="ident">generateSummary</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates data for the front page of latex report.</p>
<p>:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def generateSummary(self):
        &#34;&#34;&#34;
        Generates data for the front page of latex report.

        :return: returns nothing
        &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="dbmsbenchmarker.reporter.latexer.init"><code class="name flex">
<span>def <span class="ident">init</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates and saves front page of latex report.</p>
<p>:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def init(self):
        &#34;&#34;&#34;
        Generates and saves front page of latex report.

        :return: returns nothing
        &#34;&#34;&#34;
        # generate bar plot of total times
        reporterBar = barer(self.benchmarker)
        dfTotalSum = reporterBar.generate(numQuery=None, timer=self.benchmarker.timers, ensembler=&#39;sum&#39;)
        dfTotalProd = reporterBar.generate(numQuery=None, timer=self.benchmarker.timers, ensembler=&#39;product&#39;)
        # generate area plot of total time
        reporterArea = arear(self.benchmarker)
        dfTotalTime = reporterArea.generate(numQuery=None, timer=self.benchmarker.timers)
        if dfTotalTime is not None:
                print(tabulate(dfTotalTime,headers=dfTotalTime.columns,tablefmt=&#34;grid&#34;, floatfmt=&#34;.2f&#34;))
        # generate barh plot of total ranking
        dfTotalRank, timers = self.benchmarker.generateSortedTotalRanking()
        #print(title)
        filename = self.benchmarker.path+&#39;/total_barh_rank.png&#39;
        title = &#39;Ranking of &#39;+str(timers)+&#39; timers&#39;
        dfTotalRank.plot.barh()
        plt.xticks(fontsize=14)
        # align box to labels
        plt.tight_layout()
        # set title
        plt.legend(title=title)
        # save
        plt.savefig(filename)
        plt.close()
        print(title)
        print(tabulate(dfTotalRank,headers=dfTotalRank.columns,tablefmt=&#34;grid&#34;, floatfmt=&#34;.2f&#34;))
        if dfTotalSum is not None:
                dfTotalSum = dfTotalSum.applymap(lambda x: &#39;{:.{prec}f}&#39;.format(x, prec=2))
        if dfTotalProd is not None:
                dfTotalProd = dfTotalProd.applymap(lambda x: &#39;{:.{prec}f}&#39;.format(x, prec=2))
        dfTotalRank = dfTotalRank.applymap(lambda x: &#39;{:.{prec}f}&#39;.format(x, prec=2))
        # time for ingest
        timesLoad = {}
        for c,cd in self.benchmarker.dbms.items():
                if cd.connectiondata[&#39;active&#39;] and &#39;timeLoad&#39; in cd.connectiondata: 
                        timesLoad[self.benchmarker.dbms[c].getName()] = cd.connectiondata[&#39;timeLoad&#39;]
        # store in parameter array for replacement in templates
        parameter = self.prepare(0, 0)
        if dfTotalSum is not None:
                parameter[&#39;totalSum&#39;] = tabulate(dfTotalSum, headers=dfTotalSum.columns, tablefmt=&#34;latex&#34;, floatfmt=&#34;,.2f&#34;, stralign=&#34;right&#34;, showindex=True)
        else:
                parameter[&#39;totalSum&#39;] = &#34;&#34;
        if dfTotalProd is not None:
                parameter[&#39;totalProd&#39;] = tabulate(dfTotalProd, headers=dfTotalProd.columns, tablefmt=&#34;latex&#34;, floatfmt=&#34;,.2f&#34;, stralign=&#34;right&#34;, showindex=True)
        else:
                parameter[&#39;totalProd&#39;] = &#34;&#34;
        parameter[&#39;totalRank&#39;] = tabulate(dfTotalRank, headers=dfTotalRank.columns, tablefmt=&#34;latex&#34;, floatfmt=&#34;,.2f&#34;, stralign=&#34;right&#34;, showindex=True)
        if dfTotalTime is not None:
                listofnames = [&#39;DBMS &#39;+str(l+1) for l in range(len(dfTotalTime.columns))]
                dfTotalTimeTranslation = pd.DataFrame(dfTotalTime.columns,index=listofnames,columns=[&#39;DBMS Name&#39;])
                dfTotalTime.columns = listofnames
                parameter[&#39;totalTime&#39;] = tabulate(dfTotalTime, headers=dfTotalTime.columns, tablefmt=&#34;latex&#34;, floatfmt=&#34;,.2f&#34;, stralign=&#34;right&#34;, showindex=True)
                parameter[&#39;totalTime&#39;] += &#34;\\\\&#34;+tabulate(dfTotalTimeTranslation, headers=dfTotalTimeTranslation.columns, tablefmt=&#34;latex&#34;, floatfmt=&#34;,.2f&#34;, stralign=&#34;right&#34;, showindex=True)
        else:
                parameter[&#39;totalTime&#39;] = &#34;&#34;
        #print(timesLoad)
        if len(timesLoad) &gt; 0:
                dfIngest = pd.DataFrame.from_dict(timesLoad, orient=&#39;index&#39;)
                dfIngest.columns=[&#39;Time of Ingestion [s]&#39;]
                dfIngest.sort_values(by=[&#39;Time of Ingestion [s]&#39;], inplace=True, ascending=False)
                filename = self.benchmarker.path+&#39;/total_barh_ingest.png&#39;
                title = &#39;Ingest into &#39;+str(len(dfIngest.index))+&#39; DBMS&#39;
                dfIngest.plot.barh()
                plt.xticks(fontsize=14)
                # align box to labels
                plt.tight_layout()
                # set title
                plt.legend(title=title)
                # save
                plt.savefig(filename)
                plt.close()
                parameter[&#39;totalIngest&#39;] = tabulate(dfIngest, headers=dfIngest.columns, tablefmt=&#34;latex&#34;, floatfmt=&#34;,.2f&#34;, stralign=&#34;right&#34;, showindex=True)
        else:
                parameter[&#39;totalIngest&#39;] = &#34;&#34;
        # generate report head
        latex_output = self.useTemplate(&#39;reportHead&#39;, parameter)# self.template[&#39;reportHead&#39;].format(**parameter)
        latex_file = open(self.benchmarker.path+&#34;/benchmarks.tex&#34;, &#34;w&#34;)
        latex_file.write(latex_output)
        latex_file.close()</code></pre>
</details>
</dd>
<dt id="dbmsbenchmarker.reporter.latexer.prepare"><code class="name flex">
<span>def <span class="ident">prepare</span></span>(<span>self, numQuery=0, numTimer=0, timer=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Prepares a dict containing data about query and timer.
This will be used to fill the latex output template.
Anonymizes dbms if activated.</p>
<p>:param numQuery: Number of query to collect data from. numQuery=0 for title page
:param numTimer: Number of timer of this query. First timer is treated differently (subsubsection)
:param timer: List of timers to collect data from. timer=None for title page
:return: returns dict of data about query and timer</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">        def prepare(self, numQuery=0, numTimer=0, timer=None):
                &#34;&#34;&#34;
                Prepares a dict containing data about query and timer.
                This will be used to fill the latex output template.
                Anonymizes dbms if activated.

                :param numQuery: Number of query to collect data from. numQuery=0 for title page
                :param numTimer: Number of timer of this query. First timer is treated differently (subsubsection)
                :param timer: List of timers to collect data from. timer=None for title page
                :return: returns dict of data about query and timer
                &#34;&#34;&#34;
                result = {}
                result[&#39;now&#39;]=str(datetime.datetime.now())
                result[&#39;path&#39;]=self.benchmarker.path
                result[&#39;code&#39;]=self.benchmarker.code
                result[&#39;timeout&#39;]=str(self.benchmarker.timeout)+&#34;s&#34;
                result[&#39;numProcesses&#39;]=self.benchmarker.numProcesses
                result[&#39;runsPerConnection&#39;]=self.benchmarker.runsPerConnection
                if len(self.benchmarker.queryconfig[&#34;intro&#34;]) &gt; 0:
                        result[&#39;intro&#39;] = self.benchmarker.queryconfig[&#34;intro&#34;]+&#34;\\\\&#34;
                # list of active queries for timer #0 = execution
                qs = tools.findSuccessfulQueriesAllDBMS(self.benchmarker, None, self.benchmarker.timers)[0]
                #print(qs)
                # compute total times
                times = {}
                l = list({c for c in {c for q,d in self.benchmarker.protocol[&#39;query&#39;].items() if int(q)-1 in qs for c in d[&#39;durations&#39;].items()}})
                #print(l)
                for i,element in enumerate(l):
                        #print(element)
                        if not element[0] in times:
                                times[element[0]] = element[1]
                        else:
                                times[element[0]] += element[1]
                #print(times)
                # format dbms infos
                def initfilename(c, i):
                        return self.benchmarker.path+&#39;/&#39;+c+&#39;_init_&#39;+str(i)+&#39;.log&#39;
                def hasInitScript(c):
                        return os.path.isfile(initfilename(c,0))
                dbmsinfos = &#34;&#34;
                #for c in sorted(self.benchmarker.dbms.keys()):
                for c in sorted(self.benchmarker.dbms, key=lambda kv: self.benchmarker.dbms[kv].name):
                        if self.benchmarker.dbms[c].connectiondata[&#39;active&#39;]:
                                dbmsdata = self.benchmarker.dbms[c].getName()
                                if not self.benchmarker.anonymize:
                                        dbmsdata += &#34; (&#34;+self.benchmarker.dbms[c].connectiondata[&#34;version&#34;]+&#34;)&#34;
                                dbmsinfos += &#34;\\subsubsection{{{dbmsname}}}&#34;.format(dbmsname=dbmsdata)
                                dbmsinfos += &#34;\\begin{itemize}\n&#34;
                                info = self.benchmarker.dbms[c].connectiondata[&#34;info&#34;]
                                if len(info) &gt; 0:
                                        if not str(info) == info:
                                                dbmsinfos += &#34;\\item &#34;+(&#34;\\item &#34;.join(info))
                                if &#39;connectionmanagement&#39; in self.benchmarker.dbms[c].connectiondata:
                                        connectionmanagement = self.benchmarker.dbms[c].connectiondata[&#39;connectionmanagement&#39;]
                                        if &#34;numProcesses&#34; in connectionmanagement:
                                                dbmsinfos += &#34;\\item \\textbf{Parallel Clients}: &#34;+str(connectionmanagement[&#34;numProcesses&#34;])
                                        if &#34;runsPerConnection&#34; in connectionmanagement:
                                                if connectionmanagement[&#34;runsPerConnection&#34;] &gt; 0:
                                                        dbmsinfos += &#34;\\item \\textbf{Runs per Connection}: &#34;+str(connectionmanagement[&#34;runsPerConnection&#34;])
                                                else:
                                                        dbmsinfos += &#34;\\item \\textbf{Runs per Connection}: Unlimited&#34;
                                        if &#34;timeout&#34; in connectionmanagement:
                                                if connectionmanagement[&#34;timeout&#34;] &gt; 0:
                                                        dbmsinfos += &#34;\\item \\textbf{Timeout}: &#34;+str(connectionmanagement[&#34;timeout&#34;])
                                                else:
                                                        dbmsinfos += &#34;\\item \\textbf{Timeout}: Unlimited&#34;
                                else:
                                        #numProcesses = int(self.benchmarker.dbms[c].connectiondata[&#34;numProcesses&#34;])
                                        #if numProcesses == 0:
                                        numProcesses = int(self.benchmarker.numProcesses)
                                        if not numProcesses == 0:
                                                dbmsinfos += &#34;\\item \\textbf{Clients}: &#34;+str(numProcesses)+&#34; parallel clients&#34;
                                                if self.benchmarker.runsPerConnection &gt; 0:
                                                        dbmsinfos += &#34;\\item \\textbf{Runs per Connection}: &#34;+str(self.benchmarker.runsPerConnection)
                                                else:
                                                        dbmsinfos += &#34;\\item \\textbf{Runs per Connection}: Unlimited&#34;
                                                if self.benchmarker.timeout &gt; 0:
                                                        dbmsinfos += &#34;\\item \\textbf{Timeout}: &#34;+str(self.benchmarker.timeout)
                                                else:
                                                        dbmsinfos += &#34;\\item \\textbf{Timeout}: Unlimited&#34;
                                if &#34;CPU&#34; in self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;]:
                                        dbmsinfos += &#34;\\item \\textbf{CPU}: &#34;+self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;][&#34;CPU&#34;]
                                if &#34;Cores&#34; in self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;]:
                                        dbmsinfos += &#34;\\item \\textbf{Cores}: &#34;+self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;][&#34;Cores&#34;]
                                if &#34;RAM&#34; in self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;]:
                                        dbmsinfos += &#34;\\item \\textbf{RAM}: &#34;+str(self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;][&#34;RAM&#34;])+&#34; GB&#34;
                                if &#34;GPU&#34; in self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;]:
                                        dbmsinfos += &#34;\\item \\textbf{GPU}: &#34;+self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;][&#34;GPU&#34;]
                                if &#34;CUDA&#34; in self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;]:
                                        dbmsinfos += &#34;\\item \\textbf{CUDA}: &#34;+self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;][&#34;CUDA&#34;]
                                if &#34;host&#34; in self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;]:
                                        dbmsinfos += &#34;\\item \\textbf{Host}: &#34;+self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;][&#34;host&#34;]
                                if &#34;disk&#34; in self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;]:
                                        dbmsinfos += &#34;\\item \\textbf{Docker Disk Space Used}: &#34;+self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;][&#34;disk&#34;]
                                if &#34;instance&#34; in self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;]:
                                        dbmsinfos += &#34;\\item \\textbf{Instance}: &#34;+self.benchmarker.dbms[c].connectiondata[&#34;hostsystem&#34;][&#34;instance&#34;]
                                if &#34;timeLoad&#34; in self.benchmarker.dbms[c].connectiondata:
                                        dbmsinfos += &#34;\\item \\textbf{Time Ingest}: &#34;+tools.formatDuration(self.benchmarker.dbms[c].connectiondata[&#34;timeLoad&#34;]*1000.0)
                                if c in times:
                                        dbmsinfos += &#34;\\item \\textbf{Time Benchmarks}: &#34;+tools.formatDuration(times[c])
                                        if &#39;priceperhourdollar&#39; in self.benchmarker.dbms[c].connectiondata:
                                                if &#34;timeLoad&#34; in self.benchmarker.dbms[c].connectiondata:
                                                        time = times[c] + self.benchmarker.dbms[c].connectiondata[&#34;timeLoad&#34;]*1000.0
                                                        dbmsinfos += &#34;\\item \\textbf{Time Total}: &#34;+tools.formatDuration(time)
                                                else:
                                                        time = times[c]
                                                dbmsinfos += &#34;\\item \\textbf{{Price}}: \\${:.{prec}f} (\\${:.{prec}f}/h)&#34;.format(self.benchmarker.dbms[c].connectiondata[&#39;priceperhourdollar&#39;]*time/3600000, self.benchmarker.dbms[c].connectiondata[&#39;priceperhourdollar&#39;], prec=2)
                                if hasInitScript(c) and not self.benchmarker.dbms[c].anonymous:
                                        dbmsinfos += &#34;\\item\\hyperref[initscript:{dbms}]{{Initialisation scripts}}&#34;.format(dbms=c)
                                #dbmsinfos += &#34;\\item {}\n&#34;.format(info)
                                #dbmsinfos += &#34;\\item \\textbf{{{}}}: {}\n&#34;.format(dbmsdata, info)
                                dbmsinfos += &#34;\\end{itemize}&#34;
                result[&#39;dbmsinfos&#39;] = dbmsinfos
                # appendix start: query survey
                result[&#39;querySurvey&#39;] = &#39;&#39;
                for i in range(1, len(self.benchmarker.queries)+1):
                        queryObject = tools.query(self.benchmarker.queries[i-1])
                        result[&#39;querySurvey&#39;] += &#34;\n\\\\\\noindent\\hyperref[benchmark:{code}-Q{queryNumber}]{{\\textbf{{Q{queryNumber}: {queryTitle}}}}}\n&#34;.format(code=self.benchmarker.code, queryNumber=i, queryTitle=queryObject.title)
                        if not queryObject.active:
                                result[&#39;querySurvey&#39;] += &#39;\\\\inactive&#39;
                                continue
                        if len(self.benchmarker.protocol[&#39;query&#39;][str(i)][&#39;parameter&#39;]) &gt; 0:
                                result[&#39;querySurvey&#39;] += &#34;\\\\\\hyperref[parameter:{code}-Q{queryNumber}]{{Parametrized}}&#34;.format(**result, queryNumber=i)
                        l = self.benchmarker.protocol[&#39;query&#39;][str(i)][&#39;dataStorage&#39;]
                        if len(l) &gt; 0 and len(l[0]) &gt; 0 and len(l[0][0]) &gt; 0:
                                l = [x for l1 in l for l2 in l1 for x in l2]
                                result[&#39;querySurvey&#39;] += &#34;\\\\\\hyperref[data:{code}-Q{queryNumber}]{{Storage size}}: &#34;.format(**result, queryNumber=i)+str(sys.getsizeof(l))+&#34; bytes (&#34;+queryObject.result+&#34;)&#34;
                        for connection, error in self.benchmarker.protocol[&#39;query&#39;][str(i)][&#39;errors&#39;].items():
                                if len(error) &gt; 0 and self.benchmarker.dbms[connection].connectiondata[&#39;active&#39;]:
                                        result[&#39;querySurvey&#39;] += &#34;\\\\\\noindent &#34;+self.benchmarker.dbms[connection].getName()+&#34;: {\\textit{\\error{&#34;+tools.tex_escape(error)+&#34;}}}\n&#34;
                                        #result[&#39;querySurvey&#39;] += &#34;\\\\\\noindent &#34;+connection+&#34;: {\\tiny{\\begin{verbatim}&#34;+error+&#34;\\end{verbatim}}}\n&#34;
                                        #result[&#39;querySurvey&#39;] += &#34;\\\\&#34;+connection+&#34;: Error&#34;
                        for connection, size in self.benchmarker.protocol[&#39;query&#39;][str(i)][&#39;sizes&#39;].items():
                                if size &gt; 0 and self.benchmarker.dbms[connection].connectiondata[&#39;active&#39;]:
                                        result[&#39;querySurvey&#39;] += &#34;\\\\\\noindent &#34;+self.benchmarker.dbms[connection].getName()+&#34;: Received data = &#34;+tools.sizeof_fmt(size)+&#34;\n&#34;
                                        #result[&#39;querySurvey&#39;] += &#34;\\\\&#34;+connection+&#34;: Error&#34;
                #print(result[&#39;querySurvey&#39;])
                # format title of benchmark
                if len(self.benchmarker.queryconfig[&#34;name&#34;]) &gt; 0:
                        benchmarkName = self.benchmarker.queryconfig[&#34;name&#34;]
                else:
                        benchmarkName = self.benchmarker.path
                # if no query: title is section
                if numQuery == 0:
                        benchmarkName = &#39;\\section{%s}&#39; % (benchmarkName)
                result[&#39;benchmarkName&#39;] = benchmarkName
                summary = &#34;&#34;
                numShownPlots = 0
                for i,q in enumerate(self.benchmarker.queries):
                        if self.benchmarker.timerExecution.checkForSuccessfulBenchmarks(i+1):
                                query = tools.query(q)
                                if not query.active:
                                        #print(&#34;skip&#34;)
                                        continue
                                numShownPlots = numShownPlots + 1
                                summary += &#34;&#34;&#34;\\begin{{minipage}}[t]{{0.45\\textwidth}}
\\hyperref[benchmark:{code}-Q{queryNumber}]{{\\textbf{{Q{queryNumber}: {queryTitle}}}}}\\\\
\\includegraphics[height=0.8\\textwidth]{{query_{queryNumber}_bar.png}}
\\end{{minipage}}\n&#34;&#34;&#34;.format(code=self.benchmarker.code, path=self.benchmarker.path, queryNumber=i+1, queryTitle=query.title)
                                if i+1 &lt; len(self.benchmarker.queries) and (numShownPlots)%2:
                                        summary += &#34;\\hfill&#34;
                result[&#39;summary&#39;] = summary
                # init scripts
                result[&#39;initscript&#39;] = &#34;&#34;
                for c in self.benchmarker.dbms:
                        i = 0
                        if hasInitScript(c) and self.benchmarker.dbms[c].connectiondata[&#39;active&#39;] and not self.benchmarker.dbms[c].anonymous:
                                result[&#39;initscript&#39;] += &#34;\\newpage\n\\subsection{{Initscript {dbms}}}\\label{{initscript:{dbms}}}\n&#34;.format(dbms=c)
                                #result[&#39;initscript&#39;] += &#34;\\begin{figure}[h]\\centering\n
                                result[&#39;initscript&#39;] += &#34;\\begin{sqlFormatSmall}\n&#34;
                                while True:
                                        filename=initfilename(c,i)
                                        if os.path.isfile(filename):
                                                result[&#39;initscript&#39;] += open(filename).read()
                                                i = i + 1
                                        else:
                                                break
                                result[&#39;initscript&#39;] += &#34;\n\\end{sqlFormatSmall}\n&#34;
                                #result[&#39;initscript&#39;] += &#34;\\caption{{Init script {dbms}}}\\end{{figure}}&#34;.format(dbms=c)
                # are there benchmarks for this query?
                if numQuery &gt; 0 and self.benchmarker.timerExecution.checkForSuccessfulBenchmarks(numQuery):
                        result[&#39;queryNumber&#39;]=numQuery
                        query = tools.query(self.benchmarker.queries[numQuery-1])
                        # format duration
                        result[&#39;duration&#39;] = tools.formatDuration(self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;duration&#39;])
                        result[&#39;durations&#39;] = &#34;\\begin{itemize}\n&#34;
                        for c, d in self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;durations&#39;].items():
                                result[&#39;durations&#39;] += &#39;\\item\\textbf{&#39;+self.benchmarker.dbms[c].getName()+&#39;}: &#39;+tools.formatDuration(d)+&#39;\n&#39;
                        result[&#39;durations&#39;] += &#34;\\end{itemize}\n&#34;
                        # format errors
                        errors = &#39;&#39;
                        for key, value in self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;errors&#39;].items():
                                if not self.benchmarker.dbms[key].connectiondata[&#39;active&#39;]:
                                        continue
                                if len(value) &gt; 0:
                                        #firstpos = value.find(&#39;: &#39;)
                                        #if firstpos &gt; 0:
                                        #       #errors += &#39;\\\\&#39;+self.benchmarker.dbms[key].getName() + &#39;: \\verb|&#39; + value[(firstpos+2):] + &#39;|\\\\&#39;
                                        #       errors += &#39;\\\\&#39;+self.benchmarker.dbms[key].getName() + &#39;: \\error{&#39; + tools.tex_escape(value[(firstpos+2):]) + &#39;}\\\\&#39;
                                        #else:
                                        #       #errors += &#39;\\\\&#39;+self.benchmarker.dbms[key].getName() + &#39;: \\verb|&#39; + value + &#39;|\\\\&#39;
                                        #       errors += &#39;\\\\&#39;+self.benchmarker.dbms[key].getName() + &#39;: \\error{&#39; + tools.tex_escape(value) + &#39;}\\\\&#39;
                                        errors += &#39;\\\\&#39;+self.benchmarker.dbms[key].getName() + &#39;: \\error{&#39; + tools.tex_escape(value) + &#39;}\\\\&#39;
                        if len(errors) &gt; 0:
                                errors = &#39;\\subsubsection{{Error}}\\label{{error:{code}-Q{queryNumber}}}&#39;.format(**result)+errors
                        errors += &#39;&#39;
                        result[&#39;errors&#39;] = errors
                        # format parameter
                        parameter = &#39;&#39;
                        showParameter = self.benchmarker.queryconfig[&#34;reporting&#34;][&#34;queryparameter&#34;]
                        if showParameter:
                                if len(self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;parameter&#39;]) &gt; 0:
                                        parameter += &#39;\\subsubsection{{Parameter}}\\label{{parameter:{code}-Q{queryNumber}}}&#39;.format(**result)
                                        #parameter += &#39;\\subsubsection{Parameter}&#39;
                                        listParameter = self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;parameter&#39;]
                                        dataframeParameter = pd.DataFrame.from_records(listParameter)
                                        dataframeParameter.index=range(1,len(listParameter)+1)
                                        if showParameter == &#39;first&#39;:
                                                dataframeParameter = dataframeParameter.iloc[0:1, :]
                                        parameter += tabulate(dataframeParameter, headers=dataframeParameter.columns, tablefmt=&#34;latex&#34;, stralign=&#34;right&#34;, showindex=True)
                                        parameter += &#39;\\\\&#39;
                        result[&#39;queryParameter&#39;] = parameter
                        # data
                        result[&#39;data&#39;] = &#34;&#34;
                        showStorage = self.benchmarker.queryconfig[&#34;reporting&#34;][&#34;resultsetPerQuery&#34;]
                        if self.benchmarker.queryconfig[&#34;reporting&#34;][&#34;resultsetPerQuery&#34;]:
                                #print(&#34;resultsetPerQuery&#34;)
                                if not self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;dataStorage&#39;] is None:
                                        result[&#39;data&#39;] += &#39;\\subsubsection{{Received Data}}\\label{{data:{code}-Q{queryNumber}}}&#39;.format(**result)
                                        for i,data in enumerate(self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;dataStorage&#39;]):
                                                if data is not None and len(data) &gt; 0:
                                                        df = pd.DataFrame.from_records(data)
                                                        # first row contains column names
                                                        df.columns = df.iloc[0]
                                                        # remove first row
                                                        df = df[1:]
                                                        if query.result == &#39;result&#39;:
                                                                result[&#39;data&#39;] += &#34;\\noindent\\textbf{Result table of run &#34;+str(i+1)+&#34;}:\\\\&#34;
                                                        elif query.result == &#39;hash&#39;:
                                                                result[&#39;data&#39;] += &#34;\\noindent\\textbf{Result hash of run &#34;+str(i+1)+&#34;}:\\\\&#34;
                                                        elif query.result == &#39;size&#39;:
                                                                result[&#39;data&#39;] += &#34;\\noindent\\textbf{Result size of run &#34;+str(i+1)+&#34;}:\\\\&#34;
                                                        if query.restrict_precision:
                                                                precision = query.restrict_precision
                                                        else:
                                                                precision = 2
                                                        if df.empty:
                                                                df.loc[len(df), :] = [&#39;-&#39; for i in range(1,len(df.columns)+1)]
                                                        result[&#39;data&#39;] += tabulate(df, headers=df.columns, tablefmt=&#34;latex&#34;, stralign=&#34;right&#34;, floatfmt=&#34;,.&#34;+str(precision)+&#34;f&#34;, showindex=False)
                                                        result[&#39;data&#39;] += &#39;\\\\\n\n&#39;
                                                        if showStorage == &#34;first&#34;:
                                                                break;
                        # result sets
                        result[&#39;resultSets&#39;] = &#34;&#34;
                        showResultsets = self.benchmarker.queryconfig[&#34;reporting&#34;][&#34;resultsetPerQueryConnection&#34;]
                        if showResultsets:
                                #print(&#34;resultsetPerQueryConnection&#34;)
                                if not self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;resultSets&#39;] is None:
                                        for c, sets in self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;resultSets&#39;].items():
                                                if len(sets) &gt; 0:
                                                        # show result set because there is an error
                                                        result[&#39;resultSets&#39;] += &#39;\\subsubsection{Received Data of &#39;+self.benchmarker.dbms[c].getName()+&#39;}&#39;
                                                        for i, data in enumerate(sets):
                                                                if data is not None and len(data) &gt; 0:
                                                                        if showResultsets == &#34;differing&#34;:
                                                                                # only show result sets differing from data storage
                                                                                if len(self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;dataStorage&#39;]) &gt; i:
                                                                                        if self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;dataStorage&#39;][i] == self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;resultSets&#39;][c][i]:
                                                                                                #print(&#34;Same result for run &#34;+str(i)+&#34; of query &#34;+str(numQuery))
                                                                                                continue
                                                                                else:
                                                                                        if self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;dataStorage&#39;][0] == self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;resultSets&#39;][c][i]:
                                                                                                #print(&#34;Same result for run &#34;+str(i)+&#34; of query &#34;+str(numQuery))
                                                                                                continue
                                                                        df = pd.DataFrame.from_records(data)
                                                                        # first row contains column names
                                                                        df.columns = df.iloc[0]
                                                                        # remove first row
                                                                        df = df[1:]
                                                                        if query.result == &#39;result&#39;:
                                                                                result[&#39;resultSets&#39;] += &#34;\\noindent\\textbf{Result table of run &#34;+str(i+1)+&#34;}:\\\\&#34;
                                                                        elif query.result == &#39;hash&#39;:
                                                                                result[&#39;resultSets&#39;] += &#34;\\noindent\\textbf{Result hash of run &#34;+str(i+1)+&#34;}:\\\\&#34;
                                                                        elif query.result == &#39;size&#39;:
                                                                                result[&#39;resultSets&#39;] += &#34;\\noindent\\textbf{Result size of run &#34;+str(i+1)+&#34;}:\\\\&#34;
                                                                        if query.restrict_precision:
                                                                                precision = query.restrict_precision
                                                                        else:
                                                                                precision = 2
                                                                        if df.empty:
                                                                                df.loc[len(df), :] = [&#39;-&#39; for i in range(1,len(df.columns)+1)]
                                                                        result[&#39;resultSets&#39;] += tabulate(df, headers=df.columns, tablefmt=&#34;latex&#34;, stralign=&#34;right&#34;, floatfmt=&#34;,.&#34;+str(precision)+&#34;f&#34;, showindex=False)
                                                                        result[&#39;resultSets&#39;] += &#39;\\\\\n\n&#39;
                                                                        if showResultsets == &#34;first&#34;:
                                                                                break;
                        # format title of query
                        queryName = &#39;Query %d%s&#39; % (numQuery, &#39;: &#39;+query.title)
                        result[&#39;queryName&#39;] = queryName
                        result[&#39;queryString&#39;] = query.query
                        queryNotes = &#34;&#34;
                        for c in query.DBMS:
                                for connectionname, connection in self.benchmarker.dbms.items():
                                        if connectionname.startswith(c) and self.benchmarker.dbms[connectionname].connectiondata[&#39;active&#39;]:
                                                queryNotes += self.benchmarker.dbms[connectionname].getName() + &#39;: Different query\n\\begin{sqlFormat}\n&#39; + query.DBMS[c] + &#39;\n\\end{sqlFormat}&#39;
                        result[&#39;queryNotes&#39;] = queryNotes
                        result[&#39;warmup&#39;]=str(query.warmup)
                        result[&#39;cooldown&#39;]=str(query.cooldown)
                        result[&#39;run&#39;]=str(query.numRun)
                        result[&#39;start&#39;]=self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;start&#39;]
                        result[&#39;end&#39;]=self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;end&#39;]
                        # hardware metrics
                        result[&#39;hardwareMetrics&#39;] = &#34;&#34;
                        for connectionname, connection in self.benchmarker.dbms.items():
                                if self.benchmarker.dbms[connectionname].hasHardwareMetrics():
                                        metricsReporter = monitor.metrics(self.benchmarker)
                                        #result[&#39;hardwareMetrics&#39;] = monitor.metrics.latex.format(**result)
                                        result[&#39;hardwareMetrics&#39;] = metricsReporter.generateLatexForQuery(result)
                                        break
                        # report per timer
                        if numTimer &gt; 0:
                                result[&#39;nameTimer&#39;] = timer.name
                                # format times for output
                                header = tools.timer.header_stats.copy()
                                # add factor column
                                header.insert(1,&#34;factor&#34;)
                                # convert to DataFrame
                                dataframe = self.benchmarker.statsToDataFrame(numQuery, timer)
                                # test if any rows left
                                if dataframe.empty:
                                        return {}
                                # print transfer table in latex
                                table = tabulate(dataframe,headers=header, tablefmt=&#34;latex&#34;, stralign=&#34;right&#34;, floatfmt=&#34;,.2f&#34;, showindex=True)
                                # align dbms name to the left
                                table = table.replace(&#39;\\begin{tabular}{r&#39;, &#39;\\begin{tabular}{l&#39;)
                                result[&#39;table&#39;] = table
                                result[&#39;tableName&#39;] = &#34;Time &#34;+timer.name
                                result[&#39;timerName&#39;] = timer.name
                #print(result)
                return result</code></pre>
</details>
</dd>
<dt id="dbmsbenchmarker.reporter.latexer.readTemplates"><code class="name flex">
<span>def <span class="ident">readTemplates</span></span>(<span>self, templatefolder)</span>
</code></dt>
<dd>
<section class="desc"><p>Reads content of a template folder</p>
<p>:param timer: Timer object
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def readTemplates(self, templatefolder):
        &#34;&#34;&#34;
        Reads content of a template folder

        :param timer: Timer object
        :return: returns nothing
        &#34;&#34;&#34;
        templates = [&#39;reportHead&#39;, &#39;reportFoot&#39;, &#39;query&#39;, &#39;timer&#39;, &#39;appendix&#39;, &#39;appendixquery&#39;, &#39;appendixtimer&#39;]
        for t in templates:
                with open(&#39;latex/&#39;+templatefolder+&#34;/&#34;+t, &#39;r&#39;) as f:
                        self.template[t]=f.read()</code></pre>
</details>
</dd>
<dt id="dbmsbenchmarker.reporter.latexer.useTemplate"><code class="name flex">
<span>def <span class="ident">useTemplate</span></span>(<span>self, name, parameter)</span>
</code></dt>
<dd>
<section class="desc"><p>Applies parameter to a template and returns filled template</p>
<p>:param name: Name of the template
:param parameter: Dict of parameters
:return: returns template with filled paramter</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def useTemplate(self, name, parameter):
        &#34;&#34;&#34;
        Applies parameter to a template and returns filled template

        :param name: Name of the template
        :param parameter: Dict of parameters
        :return: returns template with filled paramter
        &#34;&#34;&#34;
        logging.debug(&#34;useTemplate: &#34;+self.templatefolder+&#34;/&#34;+name)
        return self.template[name].format(**parameter)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dbmsbenchmarker.reporter.reporter" href="#dbmsbenchmarker.reporter.reporter">reporter</a></b></code>:
<ul class="hlist">
<li><code><a title="dbmsbenchmarker.reporter.reporter.save" href="#dbmsbenchmarker.reporter.reporter.save">save</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="dbmsbenchmarker.reporter.latexerCustom"><code class="flex name class">
<span>class <span class="ident">latexerCustom</span></span>
<span>(</span><span>benchmarker)</span>
</code></dt>
<dd>
<section class="desc"><p>Class for generating reports.
This class generates a survey in latex and saves it to disk.
This is a dummy for generating custom reports.
Concept: Just change the output templates and possibly the prepare method to append/change the results list.</p>
<p>Construct a new 'reporter' object.</p>
<p>:param benchmarker: Object of benchmarker containing information about queries, connections and benchmark times
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class latexerCustom(latexer):
        &#34;&#34;&#34;
        Class for generating reports.
        This class generates a survey in latex and saves it to disk.
        This is a dummy for generating custom reports.
        Concept: Just change the output templates and possibly the prepare method to append/change the results list.
        &#34;&#34;&#34;
        def __init__(self, benchmarker):
                latexer.__init__(self, benchmarker, templatefolder=&#34;custom&#34;)
        def prepare(self, numQuery=0, numTimer=0, timer=None):
                result = latexer.prepare(numQuery, numTimer, timer)
                return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbmsbenchmarker.reporter.latexer" href="#dbmsbenchmarker.reporter.latexer">latexer</a></li>
<li><a title="dbmsbenchmarker.reporter.reporter" href="#dbmsbenchmarker.reporter.reporter">reporter</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dbmsbenchmarker.reporter.latexer" href="#dbmsbenchmarker.reporter.latexer">latexer</a></b></code>:
<ul class="hlist">
<li><code><a title="dbmsbenchmarker.reporter.latexer.generate" href="#dbmsbenchmarker.reporter.latexer.generate">generate</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.latexer.generateAll" href="#dbmsbenchmarker.reporter.latexer.generateAll">generateAll</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.latexer.generateSummary" href="#dbmsbenchmarker.reporter.latexer.generateSummary">generateSummary</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.latexer.init" href="#dbmsbenchmarker.reporter.latexer.init">init</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.latexer.prepare" href="#dbmsbenchmarker.reporter.latexer.prepare">prepare</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.latexer.readTemplates" href="#dbmsbenchmarker.reporter.latexer.readTemplates">readTemplates</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.latexer.save" href="#dbmsbenchmarker.reporter.reporter.save">save</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.latexer.useTemplate" href="#dbmsbenchmarker.reporter.latexer.useTemplate">useTemplate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="dbmsbenchmarker.reporter.latexerPagePerQuery"><code class="flex name class">
<span>class <span class="ident">latexerPagePerQuery</span></span>
<span>(</span><span>benchmarker, templatefolder)</span>
</code></dt>
<dd>
<section class="desc"><p>Class for generating reports.
This class generates a survey in latex and saves it to disk.
The survey has one page per timer.</p>
<p>Construct a new 'reporter' object.</p>
<p>:param benchmarker: Object of benchmarker containing information about queries, connections and benchmark times
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class latexerPagePerQuery(latexer):
        &#34;&#34;&#34;
        Class for generating reports.
        This class generates a survey in latex and saves it to disk.
        The survey has one page per timer.
        &#34;&#34;&#34;
        def __init__(self, benchmarker, templatefolder):
                latexer.__init__(self, benchmarker, templatefolder=&#34;pagePerQuery&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbmsbenchmarker.reporter.latexer" href="#dbmsbenchmarker.reporter.latexer">latexer</a></li>
<li><a title="dbmsbenchmarker.reporter.reporter" href="#dbmsbenchmarker.reporter.reporter">reporter</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dbmsbenchmarker.reporter.latexer" href="#dbmsbenchmarker.reporter.latexer">latexer</a></b></code>:
<ul class="hlist">
<li><code><a title="dbmsbenchmarker.reporter.latexer.generate" href="#dbmsbenchmarker.reporter.latexer.generate">generate</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.latexer.generateAll" href="#dbmsbenchmarker.reporter.latexer.generateAll">generateAll</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.latexer.generateSummary" href="#dbmsbenchmarker.reporter.latexer.generateSummary">generateSummary</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.latexer.init" href="#dbmsbenchmarker.reporter.latexer.init">init</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.latexer.prepare" href="#dbmsbenchmarker.reporter.latexer.prepare">prepare</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.latexer.readTemplates" href="#dbmsbenchmarker.reporter.latexer.readTemplates">readTemplates</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.latexer.save" href="#dbmsbenchmarker.reporter.reporter.save">save</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.latexer.useTemplate" href="#dbmsbenchmarker.reporter.latexer.useTemplate">useTemplate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="dbmsbenchmarker.reporter.metricer"><code class="flex name class">
<span>class <span class="ident">metricer</span></span>
<span>(</span><span>benchmarker)</span>
</code></dt>
<dd>
<section class="desc"><p>Class for generating reports.
Generates a plot of the benchmarks as a time series and saves it to disk.</p>
<p>Construct a new 'reporter' object.</p>
<p>:param benchmarker: Object of benchmarker containing information about queries, connections and benchmark times
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class metricer(reporter):
        &#34;&#34;&#34;
        Class for generating reports.
        Generates a plot of the benchmarks as a time series and saves it to disk.
        &#34;&#34;&#34;
        def __init__(self, benchmarker):
                reporter.__init__(self, benchmarker)
        def save(self, dataframe, title, subtitle, filename):
                &#34;&#34;&#34;
                Saves report of a given query as plot image per timer.
                Anonymizes dbms if activated.

                :param dataframe: Report data given as a pandas DataFrame (rows=dbms, cols=benchmarks)
                :param title: Title of the report
                :param subtitle: Subtitle of the report
                :param filename: Name of the file the report will be saved to
                :return: returns nothing
                &#34;&#34;&#34;
                pass
        def generate(self, numQuery, timer):
                &#34;&#34;&#34;
                Generates a plot of the benchmarks as a time series and saves it to disk.
                Anonymizes dbms if activated.

                :param numQuery: Number of query to generate report of
                :param timer: Timer containing benchmark results
                :return: returns nothing
                &#34;&#34;&#34;
                for connectionname, connection in self.benchmarker.dbms.items():
                        if connection.hasHardwareMetrics():
                                logging.debug(&#34;Hardware metrics for Q&#34;+str(numQuery))
                                metricsReporter = monitor.metrics(self.benchmarker)
                                metricsReporter.generatePlotForQuery(numQuery)
                                break
        def generateAll(self, timer):
                &#34;&#34;&#34;
                Generates all reports for the benchmarker object for a given timer.
                If benchmarker has a fixed query, only reports for this query are generated.
                A plot of the total times is generated in any case.
                Anonymizes dbms if activated.

                :param timer: Timer object
                :return: returns nothing
                &#34;&#34;&#34;
                for q, d in self.benchmarker.protocol[&#39;query&#39;].items():
                        query = tools.query(self.benchmarker.queries[int(q)-1])
                        # is query active?
                        if not query.active:
                                continue
                        self.generate(q, [])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbmsbenchmarker.reporter.reporter" href="#dbmsbenchmarker.reporter.reporter">reporter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dbmsbenchmarker.reporter.metricer.generate"><code class="name flex">
<span>def <span class="ident">generate</span></span>(<span>self, numQuery, timer)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates a plot of the benchmarks as a time series and saves it to disk.
Anonymizes dbms if activated.</p>
<p>:param numQuery: Number of query to generate report of
:param timer: Timer containing benchmark results
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def generate(self, numQuery, timer):
        &#34;&#34;&#34;
        Generates a plot of the benchmarks as a time series and saves it to disk.
        Anonymizes dbms if activated.

        :param numQuery: Number of query to generate report of
        :param timer: Timer containing benchmark results
        :return: returns nothing
        &#34;&#34;&#34;
        for connectionname, connection in self.benchmarker.dbms.items():
                if connection.hasHardwareMetrics():
                        logging.debug(&#34;Hardware metrics for Q&#34;+str(numQuery))
                        metricsReporter = monitor.metrics(self.benchmarker)
                        metricsReporter.generatePlotForQuery(numQuery)
                        break</code></pre>
</details>
</dd>
<dt id="dbmsbenchmarker.reporter.metricer.generateAll"><code class="name flex">
<span>def <span class="ident">generateAll</span></span>(<span>self, timer)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates all reports for the benchmarker object for a given timer.
If benchmarker has a fixed query, only reports for this query are generated.
A plot of the total times is generated in any case.
Anonymizes dbms if activated.</p>
<p>:param timer: Timer object
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def generateAll(self, timer):
        &#34;&#34;&#34;
        Generates all reports for the benchmarker object for a given timer.
        If benchmarker has a fixed query, only reports for this query are generated.
        A plot of the total times is generated in any case.
        Anonymizes dbms if activated.

        :param timer: Timer object
        :return: returns nothing
        &#34;&#34;&#34;
        for q, d in self.benchmarker.protocol[&#39;query&#39;].items():
                query = tools.query(self.benchmarker.queries[int(q)-1])
                # is query active?
                if not query.active:
                        continue
                self.generate(q, [])</code></pre>
</details>
</dd>
<dt id="dbmsbenchmarker.reporter.metricer.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, dataframe, title, subtitle, filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Saves report of a given query as plot image per timer.
Anonymizes dbms if activated.</p>
<p>:param dataframe: Report data given as a pandas DataFrame (rows=dbms, cols=benchmarks)
:param title: Title of the report
:param subtitle: Subtitle of the report
:param filename: Name of the file the report will be saved to
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def save(self, dataframe, title, subtitle, filename):
        &#34;&#34;&#34;
        Saves report of a given query as plot image per timer.
        Anonymizes dbms if activated.

        :param dataframe: Report data given as a pandas DataFrame (rows=dbms, cols=benchmarks)
        :param title: Title of the report
        :param subtitle: Subtitle of the report
        :param filename: Name of the file the report will be saved to
        :return: returns nothing
        &#34;&#34;&#34;
        pass</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dbmsbenchmarker.reporter.reporter" href="#dbmsbenchmarker.reporter.reporter">reporter</a></b></code>:
<ul class="hlist">
<li><code><a title="dbmsbenchmarker.reporter.reporter.init" href="#dbmsbenchmarker.reporter.reporter.init">init</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="dbmsbenchmarker.reporter.pickler"><code class="flex name class">
<span>class <span class="ident">pickler</span></span>
<span>(</span><span>benchmarker)</span>
</code></dt>
<dd>
<section class="desc"><p>Class for generating reports.
Generates a pickle file of statistics as a dataframe and saves it to disk.</p>
<p>Construct a new 'reporter' object.</p>
<p>:param benchmarker: Object of benchmarker containing information about queries, connections and benchmark times
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class pickler(reporter):
        &#34;&#34;&#34;
        Class for generating reports.
        Generates a pickle file of statistics as a dataframe and saves it to disk.
        &#34;&#34;&#34;
        def __init__(self, benchmarker):
                reporter.__init__(self, benchmarker)
        def save(self, dataframe, filename):
                &#34;&#34;&#34;
                Saves report of a given query as pickle file of a dataframe per timer.
                Anonymizes dbms if activated.

                :param dataframe: Report data given as a pandas DataFrame (rows=dbms, cols=benchmarks)
                :param title: Title of the report
                :param subtitle: Subtitle of the report
                :param filename: Name of the file the report will be saved to
                :return: returns nothing
                &#34;&#34;&#34;
                f = open(filename, &#34;wb&#34;)
                pickle.dump(dataframe, f)
                f.close()
        def generate(self, numQuery, timer):
                &#34;&#34;&#34;
                Generates a pickle file of statistics as a dataframe and saves it to disk.
                Anonymizes dbms if activated.

                :param numQuery: Number of query to generate report of
                :param timer: Timer containing benchmark results
                :return: returns nothing
                &#34;&#34;&#34;
                for t in timer:
                        # are there benchmarks for this query?
                        if not t.checkForSuccessfulBenchmarks(numQuery):
                                continue
                        query = tools.query(self.benchmarker.queries[numQuery-1])
                        # is timer active for this query?
                        if not query.timer[t.name][&#39;active&#39;]:
                                continue
                        # is query active?
                        if not query.active:
                                continue
                        # convert statistics to DataFrame
                        dataframe = self.benchmarker.statsToDataFrame(numQuery, t)
                        # test if any rows left
                        #if (dataframe[(dataframe.T[1:] != 0).any()]).empty:
                        if dataframe.empty:
                                # ignore empty dataframes
                                return
                        # remove inactive connections
                        #dataframe = tools.dataframehelper.removeInactiveConnections(dataframe, self.benchmarker)
                        # add factor column
                        #dataframe = tools.dataframehelper.addFactor(dataframe, self.benchmarker.queryconfig[&#39;factor&#39;])
                        logging.debug(&#34;Pickle Q&#34;+str(numQuery)+&#34; for timer &#34;+t.name)
                        # save as plot
                        self.save(
                                dataframe = dataframe,
                                filename = self.benchmarker.path+&#39;/query_&#39;+str(numQuery)+&#39;_&#39;+t.name+&#39;_statistics.pickle&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbmsbenchmarker.reporter.reporter" href="#dbmsbenchmarker.reporter.reporter">reporter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dbmsbenchmarker.reporter.pickler.generate"><code class="name flex">
<span>def <span class="ident">generate</span></span>(<span>self, numQuery, timer)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates a pickle file of statistics as a dataframe and saves it to disk.
Anonymizes dbms if activated.</p>
<p>:param numQuery: Number of query to generate report of
:param timer: Timer containing benchmark results
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def generate(self, numQuery, timer):
        &#34;&#34;&#34;
        Generates a pickle file of statistics as a dataframe and saves it to disk.
        Anonymizes dbms if activated.

        :param numQuery: Number of query to generate report of
        :param timer: Timer containing benchmark results
        :return: returns nothing
        &#34;&#34;&#34;
        for t in timer:
                # are there benchmarks for this query?
                if not t.checkForSuccessfulBenchmarks(numQuery):
                        continue
                query = tools.query(self.benchmarker.queries[numQuery-1])
                # is timer active for this query?
                if not query.timer[t.name][&#39;active&#39;]:
                        continue
                # is query active?
                if not query.active:
                        continue
                # convert statistics to DataFrame
                dataframe = self.benchmarker.statsToDataFrame(numQuery, t)
                # test if any rows left
                #if (dataframe[(dataframe.T[1:] != 0).any()]).empty:
                if dataframe.empty:
                        # ignore empty dataframes
                        return
                # remove inactive connections
                #dataframe = tools.dataframehelper.removeInactiveConnections(dataframe, self.benchmarker)
                # add factor column
                #dataframe = tools.dataframehelper.addFactor(dataframe, self.benchmarker.queryconfig[&#39;factor&#39;])
                logging.debug(&#34;Pickle Q&#34;+str(numQuery)+&#34; for timer &#34;+t.name)
                # save as plot
                self.save(
                        dataframe = dataframe,
                        filename = self.benchmarker.path+&#39;/query_&#39;+str(numQuery)+&#39;_&#39;+t.name+&#39;_statistics.pickle&#39;)</code></pre>
</details>
</dd>
<dt id="dbmsbenchmarker.reporter.pickler.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, dataframe, filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Saves report of a given query as pickle file of a dataframe per timer.
Anonymizes dbms if activated.</p>
<p>:param dataframe: Report data given as a pandas DataFrame (rows=dbms, cols=benchmarks)
:param title: Title of the report
:param subtitle: Subtitle of the report
:param filename: Name of the file the report will be saved to
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def save(self, dataframe, filename):
        &#34;&#34;&#34;
        Saves report of a given query as pickle file of a dataframe per timer.
        Anonymizes dbms if activated.

        :param dataframe: Report data given as a pandas DataFrame (rows=dbms, cols=benchmarks)
        :param title: Title of the report
        :param subtitle: Subtitle of the report
        :param filename: Name of the file the report will be saved to
        :return: returns nothing
        &#34;&#34;&#34;
        f = open(filename, &#34;wb&#34;)
        pickle.dump(dataframe, f)
        f.close()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dbmsbenchmarker.reporter.reporter" href="#dbmsbenchmarker.reporter.reporter">reporter</a></b></code>:
<ul class="hlist">
<li><code><a title="dbmsbenchmarker.reporter.reporter.generateAll" href="#dbmsbenchmarker.reporter.reporter.generateAll">generateAll</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.reporter.init" href="#dbmsbenchmarker.reporter.reporter.init">init</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="dbmsbenchmarker.reporter.ploter"><code class="flex name class">
<span>class <span class="ident">ploter</span></span>
<span>(</span><span>benchmarker)</span>
</code></dt>
<dd>
<section class="desc"><p>Class for generating reports.
Generates a plot of the benchmarks as a time series and saves it to disk.</p>
<p>Construct a new 'reporter' object.</p>
<p>:param benchmarker: Object of benchmarker containing information about queries, connections and benchmark times
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class ploter(reporter):
        &#34;&#34;&#34;
        Class for generating reports.
        Generates a plot of the benchmarks as a time series and saves it to disk.
        &#34;&#34;&#34;
        def __init__(self, benchmarker):
                reporter.__init__(self, benchmarker)
        def save(self, dataframe, query, title, subtitle, filename):
                &#34;&#34;&#34;
                Saves report of a given query as plot image per timer.
                Anonymizes dbms if activated.

                :param dataframe: Report data given as a pandas DataFrame (rows=dbms, cols=benchmarks)
                :param query: Query object
                :param title: Title of the report
                :param subtitle: Subtitle of the report
                :param filename: Name of the file the report will be saved to
                :return: returns nothing
                &#34;&#34;&#34;
                # test if any rows left
                if len(dataframe.index) &lt; 1:
                        return False
                # transpose
                df_transposed = dataframe.transpose()
                # add index name
                df_transposed.index.name = subtitle
                # plot
                plotdata = df_transposed.plot(title=title)
                # scale y-axis: 0 to max plus 10%
                plotdata.set_ylim(0, df_transposed.max().max()*1.10,0)
                if query.warmup &gt; 0:
                        plt.axvline(x=query.numRunBegin, linestyle=&#34;--&#34;, color=&#34;black&#34;)
                if query.cooldown &gt; 0:
                        plt.axvline(x=query.numRunEnd, linestyle=&#34;--&#34;, color=&#34;black&#34;)
                plt.legend(title=&#34;DBMS&#34;)
                plt.savefig(filename, bbox_inches=&#39;tight&#39;)
                plt.close()
        def generate(self, numQuery, timer):
                &#34;&#34;&#34;
                Generates a plot of the benchmarks as a time series and saves it to disk.
                Anonymizes dbms if activated.

                :param numQuery: Number of query to generate report of
                :param timer: Timer containing benchmark results
                :return: returns nothing
                &#34;&#34;&#34;
                for t in timer:
                        # are there benchmarks for this query?
                        if not t.checkForSuccessfulBenchmarks(numQuery):
                                continue
                        query = tools.query(self.benchmarker.queries[numQuery-1])
                        # is timer active for this query?
                        if not query.timer[t.name][&#39;active&#39;]:
                                continue
                        # is query active?
                        if not query.active:
                                continue
                        # benchmark times as a datarame
                        df = self.benchmarker.benchmarksToDataFrame(numQuery, t)
                        logging.debug(&#34;Plot Q&#34;+str(numQuery)+&#34; for timer &#34;+t.name)
                        # save as plot
                        self.save(
                                dataframe = df,
                                query = query,
                                title = &#34;Q&#34;+str(numQuery)+&#34;: Time &#34;+t.name+&#34; [ms]&#34;,
                                subtitle = &#34;Warmup = &#34;+str(query.warmup)+&#34;, test runs = &#34;+str(query.numRun-query.warmup-query.cooldown)+&#34;, cooldown = &#34;+str(query.cooldown),
                                filename = self.benchmarker.path+&#39;/query_&#39;+str(numQuery)+&#39;_&#39;+t.name+&#39;_plot.png&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbmsbenchmarker.reporter.reporter" href="#dbmsbenchmarker.reporter.reporter">reporter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dbmsbenchmarker.reporter.ploter.generate"><code class="name flex">
<span>def <span class="ident">generate</span></span>(<span>self, numQuery, timer)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates a plot of the benchmarks as a time series and saves it to disk.
Anonymizes dbms if activated.</p>
<p>:param numQuery: Number of query to generate report of
:param timer: Timer containing benchmark results
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def generate(self, numQuery, timer):
        &#34;&#34;&#34;
        Generates a plot of the benchmarks as a time series and saves it to disk.
        Anonymizes dbms if activated.

        :param numQuery: Number of query to generate report of
        :param timer: Timer containing benchmark results
        :return: returns nothing
        &#34;&#34;&#34;
        for t in timer:
                # are there benchmarks for this query?
                if not t.checkForSuccessfulBenchmarks(numQuery):
                        continue
                query = tools.query(self.benchmarker.queries[numQuery-1])
                # is timer active for this query?
                if not query.timer[t.name][&#39;active&#39;]:
                        continue
                # is query active?
                if not query.active:
                        continue
                # benchmark times as a datarame
                df = self.benchmarker.benchmarksToDataFrame(numQuery, t)
                logging.debug(&#34;Plot Q&#34;+str(numQuery)+&#34; for timer &#34;+t.name)
                # save as plot
                self.save(
                        dataframe = df,
                        query = query,
                        title = &#34;Q&#34;+str(numQuery)+&#34;: Time &#34;+t.name+&#34; [ms]&#34;,
                        subtitle = &#34;Warmup = &#34;+str(query.warmup)+&#34;, test runs = &#34;+str(query.numRun-query.warmup-query.cooldown)+&#34;, cooldown = &#34;+str(query.cooldown),
                        filename = self.benchmarker.path+&#39;/query_&#39;+str(numQuery)+&#39;_&#39;+t.name+&#39;_plot.png&#39;)</code></pre>
</details>
</dd>
<dt id="dbmsbenchmarker.reporter.ploter.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, dataframe, query, title, subtitle, filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Saves report of a given query as plot image per timer.
Anonymizes dbms if activated.</p>
<p>:param dataframe: Report data given as a pandas DataFrame (rows=dbms, cols=benchmarks)
:param query: Query object
:param title: Title of the report
:param subtitle: Subtitle of the report
:param filename: Name of the file the report will be saved to
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def save(self, dataframe, query, title, subtitle, filename):
        &#34;&#34;&#34;
        Saves report of a given query as plot image per timer.
        Anonymizes dbms if activated.

        :param dataframe: Report data given as a pandas DataFrame (rows=dbms, cols=benchmarks)
        :param query: Query object
        :param title: Title of the report
        :param subtitle: Subtitle of the report
        :param filename: Name of the file the report will be saved to
        :return: returns nothing
        &#34;&#34;&#34;
        # test if any rows left
        if len(dataframe.index) &lt; 1:
                return False
        # transpose
        df_transposed = dataframe.transpose()
        # add index name
        df_transposed.index.name = subtitle
        # plot
        plotdata = df_transposed.plot(title=title)
        # scale y-axis: 0 to max plus 10%
        plotdata.set_ylim(0, df_transposed.max().max()*1.10,0)
        if query.warmup &gt; 0:
                plt.axvline(x=query.numRunBegin, linestyle=&#34;--&#34;, color=&#34;black&#34;)
        if query.cooldown &gt; 0:
                plt.axvline(x=query.numRunEnd, linestyle=&#34;--&#34;, color=&#34;black&#34;)
        plt.legend(title=&#34;DBMS&#34;)
        plt.savefig(filename, bbox_inches=&#39;tight&#39;)
        plt.close()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dbmsbenchmarker.reporter.reporter" href="#dbmsbenchmarker.reporter.reporter">reporter</a></b></code>:
<ul class="hlist">
<li><code><a title="dbmsbenchmarker.reporter.reporter.generateAll" href="#dbmsbenchmarker.reporter.reporter.generateAll">generateAll</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.reporter.init" href="#dbmsbenchmarker.reporter.reporter.init">init</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="dbmsbenchmarker.reporter.printer"><code class="flex name class">
<span>class <span class="ident">printer</span></span>
<span>(</span><span>benchmarker)</span>
</code></dt>
<dd>
<section class="desc"><p>Class for generating reports.
This class prints a survey to console.</p>
<p>Construct a new 'reporter' object.</p>
<p>:param benchmarker: Object of benchmarker containing information about queries, connections and benchmark times
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class printer(reporter):
        &#34;&#34;&#34;
        Class for generating reports.
        This class prints a survey to console.
        &#34;&#34;&#34;
        def __init__(self, benchmarker):
                reporter.__init__(self, benchmarker)
        def generate(self, numQuery, timer):
                &#34;&#34;&#34;
                Generates report for console output.
                This currently always prints the execution timer.
                Anonymizes dbms if activated.

                :param numQuery: Number of query to generate report of
                :param timer: Timer containing benchmark results
                :return: returns nothing
                &#34;&#34;&#34;
                # are there benchmarks for this query?
                if not self.benchmarker.timerExecution.checkForSuccessfulBenchmarks(numQuery):
                        return False
                # is query active?
                query = tools.query(self.benchmarker.queries[numQuery-1])
                if not query.active:
                        return False
                # get data
                stats = self.benchmarker.timerExecution.stats[numQuery-1]
                times = self.benchmarker.timerExecution.times[numQuery-1]
                # construct table header
                header = tools.timer.header_stats.copy()
                header_times = list(map(lambda h: &#34;w&#34;+str(h)+&#34;&#34;, list(range(1,query.warmup+1))))
                header.extend(header_times)
                header_times = list(map(lambda h: str(h)+&#34;&#34;, list(range(query.warmup+1,query.numRun+1))))
                header.extend(header_times)
                # format stats and times
                stats_output = {k: [list(map(lambda x: &#39;{:.{prec}f}&#39;.format(x, prec=2), sublist)) for sublist in [stat_q]] for k,stat_q in stats.items()}
                times_output = {k: [list(map(lambda x: &#39;{:.{prec}f}&#39;.format(x, prec=2), sublist)) for sublist in [time_q]] for k,time_q in times.items()}
                # add connection names
                data = []
                for c in sorted(self.benchmarker.dbms.keys()):
                        # is dbms active and we have data
                        if self.benchmarker.dbms[c].connectiondata[&#39;active&#39;]:
                                if c in stats_output and c in times_output:
                                        l = list([self.benchmarker.dbms[c].getName()])
                                        l.extend(*stats_output[c])
                                        l.extend(*times_output[c])
                                        data.append(l)
                # print table
                print(&#39;Q&#39;+str(numQuery)+&#39;: &#39;+query.title)
                print(tabulate(data,headers=header, tablefmt=&#34;grid&#34;, floatfmt=&#34;.2f&#34;))
                # print errors
                for key, value in self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;errors&#39;].items():
                        if len(value) &gt; 0:
                                firstpos = value.find(&#39;: &#39;)
                                if firstpos &gt; 0:
                                        print(key + &#39;: &#39; + value[firstpos:])
                                else:
                                        print(key + &#39;: &#39; + value)
                return data</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbmsbenchmarker.reporter.reporter" href="#dbmsbenchmarker.reporter.reporter">reporter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dbmsbenchmarker.reporter.printer.generate"><code class="name flex">
<span>def <span class="ident">generate</span></span>(<span>self, numQuery, timer)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates report for console output.
This currently always prints the execution timer.
Anonymizes dbms if activated.</p>
<p>:param numQuery: Number of query to generate report of
:param timer: Timer containing benchmark results
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def generate(self, numQuery, timer):
        &#34;&#34;&#34;
        Generates report for console output.
        This currently always prints the execution timer.
        Anonymizes dbms if activated.

        :param numQuery: Number of query to generate report of
        :param timer: Timer containing benchmark results
        :return: returns nothing
        &#34;&#34;&#34;
        # are there benchmarks for this query?
        if not self.benchmarker.timerExecution.checkForSuccessfulBenchmarks(numQuery):
                return False
        # is query active?
        query = tools.query(self.benchmarker.queries[numQuery-1])
        if not query.active:
                return False
        # get data
        stats = self.benchmarker.timerExecution.stats[numQuery-1]
        times = self.benchmarker.timerExecution.times[numQuery-1]
        # construct table header
        header = tools.timer.header_stats.copy()
        header_times = list(map(lambda h: &#34;w&#34;+str(h)+&#34;&#34;, list(range(1,query.warmup+1))))
        header.extend(header_times)
        header_times = list(map(lambda h: str(h)+&#34;&#34;, list(range(query.warmup+1,query.numRun+1))))
        header.extend(header_times)
        # format stats and times
        stats_output = {k: [list(map(lambda x: &#39;{:.{prec}f}&#39;.format(x, prec=2), sublist)) for sublist in [stat_q]] for k,stat_q in stats.items()}
        times_output = {k: [list(map(lambda x: &#39;{:.{prec}f}&#39;.format(x, prec=2), sublist)) for sublist in [time_q]] for k,time_q in times.items()}
        # add connection names
        data = []
        for c in sorted(self.benchmarker.dbms.keys()):
                # is dbms active and we have data
                if self.benchmarker.dbms[c].connectiondata[&#39;active&#39;]:
                        if c in stats_output and c in times_output:
                                l = list([self.benchmarker.dbms[c].getName()])
                                l.extend(*stats_output[c])
                                l.extend(*times_output[c])
                                data.append(l)
        # print table
        print(&#39;Q&#39;+str(numQuery)+&#39;: &#39;+query.title)
        print(tabulate(data,headers=header, tablefmt=&#34;grid&#34;, floatfmt=&#34;.2f&#34;))
        # print errors
        for key, value in self.benchmarker.protocol[&#39;query&#39;][str(numQuery)][&#39;errors&#39;].items():
                if len(value) &gt; 0:
                        firstpos = value.find(&#39;: &#39;)
                        if firstpos &gt; 0:
                                print(key + &#39;: &#39; + value[firstpos:])
                        else:
                                print(key + &#39;: &#39; + value)
        return data</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dbmsbenchmarker.reporter.reporter" href="#dbmsbenchmarker.reporter.reporter">reporter</a></b></code>:
<ul class="hlist">
<li><code><a title="dbmsbenchmarker.reporter.reporter.generateAll" href="#dbmsbenchmarker.reporter.reporter.generateAll">generateAll</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.reporter.init" href="#dbmsbenchmarker.reporter.reporter.init">init</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.reporter.save" href="#dbmsbenchmarker.reporter.reporter.save">save</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="dbmsbenchmarker.reporter.reporter"><code class="flex name class">
<span>class <span class="ident">reporter</span></span>
<span>(</span><span>benchmarker)</span>
</code></dt>
<dd>
<section class="desc"><p>Class for generating reports.
This class serves as a base class and does not produce anything.</p>
<p>Construct a new 'reporter' object.</p>
<p>:param benchmarker: Object of benchmarker containing information about queries, connections and benchmark times
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class reporter():
        &#34;&#34;&#34;
        Class for generating reports.
        This class serves as a base class and does not produce anything.
        &#34;&#34;&#34;
        def __init__(self, benchmarker):
                &#34;&#34;&#34;
                Construct a new &#39;reporter&#39; object.

                :param benchmarker: Object of benchmarker containing information about queries, connections and benchmark times
                :return: returns nothing
                &#34;&#34;&#34;
                self.benchmarker = benchmarker
        def init(self):
                &#34;&#34;&#34;
                Initializes report. This method is called every time a report is generated.

                :return: returns nothing
                &#34;&#34;&#34;
                pass
        def save(self, dataframe, title, subtitle, filename):
                &#34;&#34;&#34;
                Saves a report.

                :param dataframe: Report data given as a pandas DataFrame
                :param title: Title of the report
                :param subtitle: Subtitle of the report
                :param filename: Name of the file the report will be saved to
                :return: returns nothing
                &#34;&#34;&#34;
                pass
        def generate(self, numQuery, timer):
                &#34;&#34;&#34;
                Generates a report for a given query and a given timer.

                :param numQuery: Number of the query the report is about. Starts at 1.
                :param timer: Timer object
                :return: returns nothing
                &#34;&#34;&#34;
                # are there benchmarks for this query?
                print(&#34;Generate report&#34;)
                if not self.benchmarker.timerExecution.checkForSuccessfulBenchmarks(numQuery):
                        print(&#34;Missing data&#34;)
        def generateAll(self, timer):
                &#34;&#34;&#34;
                Generates all reports for the benchmarker object for a given timer.
                If benchmarker has a fixed query, only reports for this query are generated.

                :param timer: Timer object
                :return: returns nothing
                &#34;&#34;&#34;
                if not self.benchmarker.fixedQuery is None:
                        self.generate(self.benchmarker.fixedQuery, timer)
                else:
                        if self.benchmarker.bBatch:
                                range_runs = range(1,len(self.benchmarker.queries)+1)
                        else:
                                range_runs = tqdm(range(1,len(self.benchmarker.queries)+1))
                        for numQuery in range_runs:
                                self.generate(numQuery, timer)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="dbmsbenchmarker.reporter.storer" href="#dbmsbenchmarker.reporter.storer">storer</a></li>
<li><a title="dbmsbenchmarker.reporter.printer" href="#dbmsbenchmarker.reporter.printer">printer</a></li>
<li><a title="dbmsbenchmarker.reporter.pickler" href="#dbmsbenchmarker.reporter.pickler">pickler</a></li>
<li><a title="dbmsbenchmarker.reporter.ploter" href="#dbmsbenchmarker.reporter.ploter">ploter</a></li>
<li><a title="dbmsbenchmarker.reporter.dataframer" href="#dbmsbenchmarker.reporter.dataframer">dataframer</a></li>
<li><a title="dbmsbenchmarker.reporter.boxploter" href="#dbmsbenchmarker.reporter.boxploter">boxploter</a></li>
<li><a title="dbmsbenchmarker.reporter.barer" href="#dbmsbenchmarker.reporter.barer">barer</a></li>
<li><a title="dbmsbenchmarker.reporter.arear" href="#dbmsbenchmarker.reporter.arear">arear</a></li>
<li><a title="dbmsbenchmarker.reporter.metricer" href="#dbmsbenchmarker.reporter.metricer">metricer</a></li>
<li><a title="dbmsbenchmarker.reporter.latexer" href="#dbmsbenchmarker.reporter.latexer">latexer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dbmsbenchmarker.reporter.reporter.generate"><code class="name flex">
<span>def <span class="ident">generate</span></span>(<span>self, numQuery, timer)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates a report for a given query and a given timer.</p>
<p>:param numQuery: Number of the query the report is about. Starts at 1.
:param timer: Timer object
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def generate(self, numQuery, timer):
        &#34;&#34;&#34;
        Generates a report for a given query and a given timer.

        :param numQuery: Number of the query the report is about. Starts at 1.
        :param timer: Timer object
        :return: returns nothing
        &#34;&#34;&#34;
        # are there benchmarks for this query?
        print(&#34;Generate report&#34;)
        if not self.benchmarker.timerExecution.checkForSuccessfulBenchmarks(numQuery):
                print(&#34;Missing data&#34;)</code></pre>
</details>
</dd>
<dt id="dbmsbenchmarker.reporter.reporter.generateAll"><code class="name flex">
<span>def <span class="ident">generateAll</span></span>(<span>self, timer)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates all reports for the benchmarker object for a given timer.
If benchmarker has a fixed query, only reports for this query are generated.</p>
<p>:param timer: Timer object
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def generateAll(self, timer):
        &#34;&#34;&#34;
        Generates all reports for the benchmarker object for a given timer.
        If benchmarker has a fixed query, only reports for this query are generated.

        :param timer: Timer object
        :return: returns nothing
        &#34;&#34;&#34;
        if not self.benchmarker.fixedQuery is None:
                self.generate(self.benchmarker.fixedQuery, timer)
        else:
                if self.benchmarker.bBatch:
                        range_runs = range(1,len(self.benchmarker.queries)+1)
                else:
                        range_runs = tqdm(range(1,len(self.benchmarker.queries)+1))
                for numQuery in range_runs:
                        self.generate(numQuery, timer)</code></pre>
</details>
</dd>
<dt id="dbmsbenchmarker.reporter.reporter.init"><code class="name flex">
<span>def <span class="ident">init</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Initializes report. This method is called every time a report is generated.</p>
<p>:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def init(self):
        &#34;&#34;&#34;
        Initializes report. This method is called every time a report is generated.

        :return: returns nothing
        &#34;&#34;&#34;
        pass</code></pre>
</details>
</dd>
<dt id="dbmsbenchmarker.reporter.reporter.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, dataframe, title, subtitle, filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Saves a report.</p>
<p>:param dataframe: Report data given as a pandas DataFrame
:param title: Title of the report
:param subtitle: Subtitle of the report
:param filename: Name of the file the report will be saved to
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def save(self, dataframe, title, subtitle, filename):
        &#34;&#34;&#34;
        Saves a report.

        :param dataframe: Report data given as a pandas DataFrame
        :param title: Title of the report
        :param subtitle: Subtitle of the report
        :param filename: Name of the file the report will be saved to
        :return: returns nothing
        &#34;&#34;&#34;
        pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dbmsbenchmarker.reporter.storer"><code class="flex name class">
<span>class <span class="ident">storer</span></span>
<span>(</span><span>benchmarker)</span>
</code></dt>
<dd>
<section class="desc"><p>Class for generating reports.
This class saves a protocol in json and benchmarks as csv files.
It also provides a load() method to restore previous benchmarks.</p>
<p>Construct a new 'reporter' object.</p>
<p>:param benchmarker: Object of benchmarker containing information about queries, connections and benchmark times
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class storer(reporter):
        &#34;&#34;&#34;
        Class for generating reports.
        This class saves a protocol in json and benchmarks as csv files.
        It also provides a load() method to restore previous benchmarks.
        &#34;&#34;&#34;
        def __init__(self, benchmarker):
                reporter.__init__(self, benchmarker)
        def save(self, dataframe, filename):
                &#34;&#34;&#34;
                Saves benchmark table of a query as csv file.

                :param dataframe: DataFrame containing connection names (columns) and benchmark times (rows)
                :param filename: Filename for csv file
                :return: returns nothing
                &#34;&#34;&#34;
                # transpose
                dft = dataframe.transpose()
                # set column names
                dft.columns = dft.iloc[0]
                # remove first row
                df_transposed = dft[1:]
                # convert to csv
                csv = df_transposed.to_csv(index_label=False,index=False)
                # save
                csv_file = open(filename, &#34;w&#34;)
                csv_file.write(csv)
                csv_file.close()
        def generate(self, numQuery, timer):
                &#34;&#34;&#34;
                Generates and saves a benchmark table of a given query as csv files per timer.

                :param numQuery: Number of query to save benchmarks of
                :param timer: Timer containing benchmark results
                :return: returns nothing
                &#34;&#34;&#34;
                self.writeProtocol()
                for t in timer:
                        # are there benchmarks for this query?
                        if not t.checkForSuccessfulBenchmarks(numQuery):
                                continue
                        logging.debug(&#34;saveBenchmarkOfQuery: &#34;+str(numQuery))
                        query = tools.query(self.benchmarker.queries[numQuery-1])
                        df = t.toDataFrame(numQuery)
                        # save as csv
                        self.save(
                                dataframe = df,
                                filename = self.benchmarker.path+&#39;/query_&#39;+str(numQuery)+&#39;_&#39;+t.name+&#39;.csv&#39;)
        def load(self, query, numQuery, timer):
                &#34;&#34;&#34;
                Loads benchmark table of a given query from csv files per timer.

                :param numQuery: Number of query to save benchmarks of
                :param query: Query object, because number of warmups is needed
                :param timer: Timer containing benchmark results
                :return: True if successful
                &#34;&#34;&#34;
                for t in timer:
                        # load execution benchmarks
                        filename = self.benchmarker.path+&#39;/query_&#39;+str(numQuery)+&#39;_&#39;+t.name+&#39;.csv&#39;
                        if os.path.isfile(filename):
                                df = pd.read_csv(filename)
                                df_t = df.transpose()
                                d = df.to_dict(orient=&#34;list&#34;)
                                t.appendTimes(d, query)#.warmup)
                                logging.debug(&#34;Read &#34;+filename)
                        else:
                                t.appendTimes({}, query)#.warmup)
                                logging.debug(filename + &#34; not found&#34;)
                                #return False
                return True
        def writeProtocol(self):
                &#34;&#34;&#34;
                Saves procol of benchmarker in JSON format.

                :return: returns nothing
                &#34;&#34;&#34;
                filename = self.benchmarker.path+&#39;/protocol.json&#39;
                with open(filename, &#39;w&#39;) as f:
                        json.dump(self.benchmarker.protocol, f)
        def readProtocol(self):
                &#34;&#34;&#34;
                Loads procol of benchmarker in JSON format.

                :return: returns nothing
                &#34;&#34;&#34;
                filename = self.benchmarker.path+&#39;/protocol.json&#39;
                with open(filename, &#39;r&#39;) as f:
                        self.benchmarker.protocol = json.load(f)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbmsbenchmarker.reporter.reporter" href="#dbmsbenchmarker.reporter.reporter">reporter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dbmsbenchmarker.reporter.storer.generate"><code class="name flex">
<span>def <span class="ident">generate</span></span>(<span>self, numQuery, timer)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates and saves a benchmark table of a given query as csv files per timer.</p>
<p>:param numQuery: Number of query to save benchmarks of
:param timer: Timer containing benchmark results
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def generate(self, numQuery, timer):
        &#34;&#34;&#34;
        Generates and saves a benchmark table of a given query as csv files per timer.

        :param numQuery: Number of query to save benchmarks of
        :param timer: Timer containing benchmark results
        :return: returns nothing
        &#34;&#34;&#34;
        self.writeProtocol()
        for t in timer:
                # are there benchmarks for this query?
                if not t.checkForSuccessfulBenchmarks(numQuery):
                        continue
                logging.debug(&#34;saveBenchmarkOfQuery: &#34;+str(numQuery))
                query = tools.query(self.benchmarker.queries[numQuery-1])
                df = t.toDataFrame(numQuery)
                # save as csv
                self.save(
                        dataframe = df,
                        filename = self.benchmarker.path+&#39;/query_&#39;+str(numQuery)+&#39;_&#39;+t.name+&#39;.csv&#39;)</code></pre>
</details>
</dd>
<dt id="dbmsbenchmarker.reporter.storer.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self, query, numQuery, timer)</span>
</code></dt>
<dd>
<section class="desc"><p>Loads benchmark table of a given query from csv files per timer.</p>
<p>:param numQuery: Number of query to save benchmarks of
:param query: Query object, because number of warmups is needed
:param timer: Timer containing benchmark results
:return: True if successful</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def load(self, query, numQuery, timer):
        &#34;&#34;&#34;
        Loads benchmark table of a given query from csv files per timer.

        :param numQuery: Number of query to save benchmarks of
        :param query: Query object, because number of warmups is needed
        :param timer: Timer containing benchmark results
        :return: True if successful
        &#34;&#34;&#34;
        for t in timer:
                # load execution benchmarks
                filename = self.benchmarker.path+&#39;/query_&#39;+str(numQuery)+&#39;_&#39;+t.name+&#39;.csv&#39;
                if os.path.isfile(filename):
                        df = pd.read_csv(filename)
                        df_t = df.transpose()
                        d = df.to_dict(orient=&#34;list&#34;)
                        t.appendTimes(d, query)#.warmup)
                        logging.debug(&#34;Read &#34;+filename)
                else:
                        t.appendTimes({}, query)#.warmup)
                        logging.debug(filename + &#34; not found&#34;)
                        #return False
        return True</code></pre>
</details>
</dd>
<dt id="dbmsbenchmarker.reporter.storer.readProtocol"><code class="name flex">
<span>def <span class="ident">readProtocol</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Loads procol of benchmarker in JSON format.</p>
<p>:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def readProtocol(self):
        &#34;&#34;&#34;
        Loads procol of benchmarker in JSON format.

        :return: returns nothing
        &#34;&#34;&#34;
        filename = self.benchmarker.path+&#39;/protocol.json&#39;
        with open(filename, &#39;r&#39;) as f:
                self.benchmarker.protocol = json.load(f)</code></pre>
</details>
</dd>
<dt id="dbmsbenchmarker.reporter.storer.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, dataframe, filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Saves benchmark table of a query as csv file.</p>
<p>:param dataframe: DataFrame containing connection names (columns) and benchmark times (rows)
:param filename: Filename for csv file
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def save(self, dataframe, filename):
        &#34;&#34;&#34;
        Saves benchmark table of a query as csv file.

        :param dataframe: DataFrame containing connection names (columns) and benchmark times (rows)
        :param filename: Filename for csv file
        :return: returns nothing
        &#34;&#34;&#34;
        # transpose
        dft = dataframe.transpose()
        # set column names
        dft.columns = dft.iloc[0]
        # remove first row
        df_transposed = dft[1:]
        # convert to csv
        csv = df_transposed.to_csv(index_label=False,index=False)
        # save
        csv_file = open(filename, &#34;w&#34;)
        csv_file.write(csv)
        csv_file.close()</code></pre>
</details>
</dd>
<dt id="dbmsbenchmarker.reporter.storer.writeProtocol"><code class="name flex">
<span>def <span class="ident">writeProtocol</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Saves procol of benchmarker in JSON format.</p>
<p>:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def writeProtocol(self):
        &#34;&#34;&#34;
        Saves procol of benchmarker in JSON format.

        :return: returns nothing
        &#34;&#34;&#34;
        filename = self.benchmarker.path+&#39;/protocol.json&#39;
        with open(filename, &#39;w&#39;) as f:
                json.dump(self.benchmarker.protocol, f)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dbmsbenchmarker.reporter.reporter" href="#dbmsbenchmarker.reporter.reporter">reporter</a></b></code>:
<ul class="hlist">
<li><code><a title="dbmsbenchmarker.reporter.reporter.generateAll" href="#dbmsbenchmarker.reporter.reporter.generateAll">generateAll</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.reporter.init" href="#dbmsbenchmarker.reporter.reporter.init">init</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dbmsbenchmarker" href="index.html">dbmsbenchmarker</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dbmsbenchmarker.reporter.arear" href="#dbmsbenchmarker.reporter.arear">arear</a></code></h4>
<ul class="">
<li><code><a title="dbmsbenchmarker.reporter.arear.generate" href="#dbmsbenchmarker.reporter.arear.generate">generate</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.arear.generateAll" href="#dbmsbenchmarker.reporter.arear.generateAll">generateAll</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.arear.save" href="#dbmsbenchmarker.reporter.arear.save">save</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dbmsbenchmarker.reporter.barer" href="#dbmsbenchmarker.reporter.barer">barer</a></code></h4>
<ul class="">
<li><code><a title="dbmsbenchmarker.reporter.barer.generate" href="#dbmsbenchmarker.reporter.barer.generate">generate</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.barer.generateAll" href="#dbmsbenchmarker.reporter.barer.generateAll">generateAll</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.barer.save" href="#dbmsbenchmarker.reporter.barer.save">save</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dbmsbenchmarker.reporter.boxploter" href="#dbmsbenchmarker.reporter.boxploter">boxploter</a></code></h4>
<ul class="">
<li><code><a title="dbmsbenchmarker.reporter.boxploter.generate" href="#dbmsbenchmarker.reporter.boxploter.generate">generate</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.boxploter.save" href="#dbmsbenchmarker.reporter.boxploter.save">save</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dbmsbenchmarker.reporter.dataframer" href="#dbmsbenchmarker.reporter.dataframer">dataframer</a></code></h4>
<ul class="">
<li><code><a title="dbmsbenchmarker.reporter.dataframer.generate" href="#dbmsbenchmarker.reporter.dataframer.generate">generate</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.dataframer.save" href="#dbmsbenchmarker.reporter.dataframer.save">save</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dbmsbenchmarker.reporter.latexer" href="#dbmsbenchmarker.reporter.latexer">latexer</a></code></h4>
<ul class="two-column">
<li><code><a title="dbmsbenchmarker.reporter.latexer.generate" href="#dbmsbenchmarker.reporter.latexer.generate">generate</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.latexer.generateAll" href="#dbmsbenchmarker.reporter.latexer.generateAll">generateAll</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.latexer.generateSummary" href="#dbmsbenchmarker.reporter.latexer.generateSummary">generateSummary</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.latexer.init" href="#dbmsbenchmarker.reporter.latexer.init">init</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.latexer.prepare" href="#dbmsbenchmarker.reporter.latexer.prepare">prepare</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.latexer.readTemplates" href="#dbmsbenchmarker.reporter.latexer.readTemplates">readTemplates</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.latexer.useTemplate" href="#dbmsbenchmarker.reporter.latexer.useTemplate">useTemplate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dbmsbenchmarker.reporter.latexerCustom" href="#dbmsbenchmarker.reporter.latexerCustom">latexerCustom</a></code></h4>
</li>
<li>
<h4><code><a title="dbmsbenchmarker.reporter.latexerPagePerQuery" href="#dbmsbenchmarker.reporter.latexerPagePerQuery">latexerPagePerQuery</a></code></h4>
</li>
<li>
<h4><code><a title="dbmsbenchmarker.reporter.metricer" href="#dbmsbenchmarker.reporter.metricer">metricer</a></code></h4>
<ul class="">
<li><code><a title="dbmsbenchmarker.reporter.metricer.generate" href="#dbmsbenchmarker.reporter.metricer.generate">generate</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.metricer.generateAll" href="#dbmsbenchmarker.reporter.metricer.generateAll">generateAll</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.metricer.save" href="#dbmsbenchmarker.reporter.metricer.save">save</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dbmsbenchmarker.reporter.pickler" href="#dbmsbenchmarker.reporter.pickler">pickler</a></code></h4>
<ul class="">
<li><code><a title="dbmsbenchmarker.reporter.pickler.generate" href="#dbmsbenchmarker.reporter.pickler.generate">generate</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.pickler.save" href="#dbmsbenchmarker.reporter.pickler.save">save</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dbmsbenchmarker.reporter.ploter" href="#dbmsbenchmarker.reporter.ploter">ploter</a></code></h4>
<ul class="">
<li><code><a title="dbmsbenchmarker.reporter.ploter.generate" href="#dbmsbenchmarker.reporter.ploter.generate">generate</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.ploter.save" href="#dbmsbenchmarker.reporter.ploter.save">save</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dbmsbenchmarker.reporter.printer" href="#dbmsbenchmarker.reporter.printer">printer</a></code></h4>
<ul class="">
<li><code><a title="dbmsbenchmarker.reporter.printer.generate" href="#dbmsbenchmarker.reporter.printer.generate">generate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dbmsbenchmarker.reporter.reporter" href="#dbmsbenchmarker.reporter.reporter">reporter</a></code></h4>
<ul class="">
<li><code><a title="dbmsbenchmarker.reporter.reporter.generate" href="#dbmsbenchmarker.reporter.reporter.generate">generate</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.reporter.generateAll" href="#dbmsbenchmarker.reporter.reporter.generateAll">generateAll</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.reporter.init" href="#dbmsbenchmarker.reporter.reporter.init">init</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.reporter.save" href="#dbmsbenchmarker.reporter.reporter.save">save</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dbmsbenchmarker.reporter.storer" href="#dbmsbenchmarker.reporter.storer">storer</a></code></h4>
<ul class="">
<li><code><a title="dbmsbenchmarker.reporter.storer.generate" href="#dbmsbenchmarker.reporter.storer.generate">generate</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.storer.load" href="#dbmsbenchmarker.reporter.storer.load">load</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.storer.readProtocol" href="#dbmsbenchmarker.reporter.storer.readProtocol">readProtocol</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.storer.save" href="#dbmsbenchmarker.reporter.storer.save">save</a></code></li>
<li><code><a title="dbmsbenchmarker.reporter.storer.writeProtocol" href="#dbmsbenchmarker.reporter.storer.writeProtocol">writeProtocol</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>